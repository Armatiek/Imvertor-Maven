<?xml version="1.0" encoding="UTF-8"?>
<!-- 
 * Copyright (C) 2016 Dienst voor het kadaster en de openbare registers
 * 
 * This file is part of Imvertor.
 *
 * Imvertor is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Imvertor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Imvertor.  If not, see <http://www.gnu.org/licenses/>.
-->
<xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:UML="omg.org/UML1.3"
    
    xmlns:imvert="http://www.imvertor.org/schema/system"
    xmlns:ext="http://www.imvertor.org/xsl/extensions"
    xmlns:imf="http://www.imvertor.org/xsl/functions"
   
    xmlns:ekf="http://EliotKimber/functions"

    xmlns:StUF="http://www.stufstandaarden.nl/StUF/StUF0302" 
    xmlns:metadata="http://www.kinggemeenten.nl/metadataVoorVerwerking" 
   
    xmlns:bg="http://www.egem.nl/StUF/sector/bg/0310" 
    xmlns:ztc="http://www.kinggemeenten.nl/ztc0310" 
    xmlns:gml="http://www.opengis.net/gml/3.2"
    
    exclude-result-prefixes="xsl UML imvert imvert ekf"
    version="2.0">
    
    <!-- TODO als in onderzoek (tv), dan het element <xs:element name="inOnderzoek" type="xs:boolean"/> 
        
        Ja, uitlezen uit het SIM.
        henri levert de specs.
        zie #487922
        -->
    
    <xsl:import href="../common/Imvert-common.xsl"/>
    <xsl:import href="../common/Imvert-common-derivation.xsl"/>
    
    <xsl:param name="prefix" select="'bg'"/>
    <xsl:param name="target-namespace" select="'http://www.egem.nl/StUF/sector/bg/0310'"/>
    
    <xsl:output indent="yes" method="xml" encoding="UTF-8"/>
    
    <xsl:variable name="stylesheet-code">BES</xsl:variable>
    <xsl:variable name="debugging" select="imf:debug-mode($stylesheet-code)"/>

    <xsl:variable name="xsd-folder-path" select="imf:get-config-string('system','xsd-folder-path')"/>
    <xsl:variable name="allow-comments-in-schema" select="true() or $debug = 'true'"/>
    
    <xsl:variable 
        name="external-schema-names" 
        select="$imvert-document//imvert:package[imvert:stereotype=(imf:get-config-stereotypes(('stereotype-name-external-package','stereotype-name-system-package')))]/imvert:name" 
        as="xs:string*"/>
    
    <xsl:variable name="elementFormDefault" select="if (imf:boolean(imf:get-config-string('cli','elementisqualified','yes'))) then 'qualified' else 'unqualified'"/>
    <xsl:variable name="attributeFormDefault" select="if (imf:boolean(imf:get-config-string('cli','attributeisqualified','no'))) then 'qualified' else 'unqualified'"/>
   
    <xsl:template match="/">
        <root/><!-- dummy output -->
        <xsl:apply-templates select="imvert:packages"/>
    </xsl:template>
    
    <xsl:template match="imvert:packages">
        <xsl:variable name="schemafile" select="concat($xsd-folder-path,'RESULT.XSD')"/>
        <xsl:variable name="schema" as="element()">
            <xs:schema 
                attributeFormDefault="{$attributeFormDefault}" 
                elementFormDefault="{$elementFormDefault}" 
                targetNamespace="{$target-namespace}" 
                version="010000" 
                xmlns="http://www.w3.org/2001/XMLSchema">

                <!--<xs:import schemaLocation="file:/d:/projects/validprojects/KING/input/ztc0310/bg0310_simpleTypes.xsd" namespace="http://www.egem.nl/StUF/sector/bg/0310" />-->
                <xs:import schemaLocation="../StUF/StUF0302.xsd" namespace="http://www.stufstandaarden.nl/StUF/StUF0302" />
                <xs:import schemaLocation="../gml/3.2.1/gml.xsd" namespace="http://www.opengis.net/gml/3.2" />
                
                <xs:annotation>
                    <xs:appinfo><xsl:value-of select="concat('Generated by ', $imvertor-version,' at ',imf:format-dateTime(current-dateTime()))"/></xs:appinfo>
                </xs:annotation>
              
                <xs:annotation>
                    <xs:documentation>(Declaratie van Basistypen)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-objecttype')]" mode="mode-global-objecttype"/>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Associatietypen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:association[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-relatiesoort')]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-association-type"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Kerngegevens)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-objecttype')]" mode="mode-global-kerngegevens"/>
                
                <xs:annotation>
                    <xs:documentation>(Gegevensgroeptypen)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-composite')]" mode="mode-global-gegevensgroeptype"/>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Attribuuttypen) </xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[imf:get-stereotype(.) = imf:get-config-stereotypes(('stereotype-name-attribute','stereotype-name-data-element'))]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-type"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Complex types)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-complextype')]" mode="mode-global-complextype"/>
       
                <!--
                    Als geen type-ID beschikbaar is, is het een "bare type" (zoals AN80). 
                -->
                <xs:annotation>
                    <xs:documentation>(Declaratie van Simpletype attributen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[empty(imvert:type-id)]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-simpletype"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van niet-Simple datatype attributen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[exists(imvert:type-id)]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-niet-simpletype"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Referentielijsten)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-referentielijst')]" mode="mode-global-referentielijst"/>
                
                <?x
                <xs:annotation>
                    <xs:documentation>(Declaratie van referentie elementen) </xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[imf:get-stereotype(../..) = imf:get-config-stereotypes('stereotype-name-referentielijst')]" 
                    group-by="imf:get-compiled-name(.)">
                    <!-- let op: referentie elementen hebben stereotype "element" -->
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-referentieelement"/>
                </xsl:for-each-group>
                ?>
                
                <?x DEZE WORDEN NIET GEDECLAREERD MAAR METEEN INGEVOEGD IN DE ATTRIBUUT DEFINITIE
                <xs:annotation>
                    <xs:documentation>(Declaratie van Enumeraties)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-enumeration')]" mode="mode-global-enumeration"/>
                ?>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Unions)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-union')]" mode="mode-global-union"/>
            </xs:schema>
        </xsl:variable>
        
        <xsl:result-document href="{$schemafile}" method="xml" indent="yes" encoding="UTF-8" exclude-result-prefixes="#all">
            <xsl:apply-templates select="$schema" mode="xsd-cleanup"/>
        </xsl:result-document>
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-objecttype">
        <xsl:variable name="hisform-on-attributes" select=".//imvert:attribute[imf:get-history(.)[1]]"/>
        <xsl:variable name="hismate-on-attributes" select=".//imvert:attribute[imf:get-history(.)[2]]"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:variable name="superclasses" select="imf:get-superclass(.)"/>
        <xsl:variable name="subclasses" select="imf:get-subclasses(.)"/>
        
        <xsl:variable name="is-supertype" select="exists($subclasses)"/>
        <xsl:variable name="is-subtype" select="exists($superclasses)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype # ',imvert:name/@original))"/>
        
        <xsl:variable name="basis-body" as="element()">
            <xs:sequence>
                <xsl:sequence select="imf:create-comment('mode-global-objecttype (Attributes)')"/>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>
                
                <xsl:sequence select="imf:create-comment('mode-global-objecttype (Compositie relaties)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[imvert:aggregation = 'composite']" mode="mode-local-composition"/>
                
                <xsl:if test="not($is-subtype)">
                    <xsl:sequence select="imf:create-comment('(History)')"/>
                    <xs:element ref="StUF:tijdvakObject" minOccurs="0"/>
                    <!--alleen genereren als er materiele historie is (dus één van de elementen heeft materiele historie = ja). -->
                    <xsl:if test="exists($hismate-on-attributes)">
                        <xs:element ref="StUF:tijdvakGeldigheid" minOccurs="0"/>
                    </xsl:if>
                    <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                    <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                    <xs:element ref="StUF:aanvullendeElementen" minOccurs="0"/>
                </xsl:if>

                <xsl:if test="$hismate-on-attributes">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', imvert:alias,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="$hisform-on-attributes">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', imvert:alias,'-basis')}"  
                        minOccurs="0" 
                        maxOccurs="unbounded"/>  
                </xsl:if>
                
                <xsl:sequence select="imf:create-comment('mode-global-objecttype (Associations: uitgaand)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[not(imvert:aggregation = 'composite')]" mode="mode-local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
                
                <!--TODO #487922 besluit nemen over terugrelaties -->
                <?mogelijk-vervallen
                <xsl:sequence select="imf:insert-comment('mode-global-objecttype (Associations: inkomend)')"/>
                <xsl:variable name="inkomende-associaties" select="$document//imvert:association[not(imvert:aggregation = 'composite') and imf:get-type-id(.) = $id]"/>
                <xsl:apply-templates select="$inkomende-associaties" mode="mode-local-association">
                    <xsl:with-param name="richting">inkomend</xsl:with-param>
                </xsl:apply-templates>
                ?>
            </xs:sequence>
        </xsl:variable>
        
        <xsl:if test="not($is-subtype)">
            <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype is not a subtype # ',imvert:name/@original))"/>
            <xs:complexType name="{imvert:alias}-basis">
                <xsl:sequence select="imf:create-annotation(.)"/>
                <xsl:sequence select="$basis-body"/>
                <xs:attribute name="entiteittype" type="{concat($prefix,':Entiteittype',imvert:alias)}"/>
                <xs:attributeGroup ref="StUF:entiteit"/>
            </xs:complexType>
            
            <xs:simpleType name="{concat('Entiteittype',imvert:alias)}">
                <xs:restriction base="string">
                    <xs:enumeration value="{imvert:alias}"/>
                </xs:restriction>
            </xs:simpleType>
        </xsl:if>
        
        <xsl:if test="$is-supertype">
            <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype is supertype # ',imvert:name/@original))"/>
            <xs:complexType name="{imvert:alias}-abstract">
                <xsl:sequence select="imf:create-annotation(.)"/>
                <xs:complexContent>
                    <xs:restriction base="{concat($prefix,':',imvert:alias,'-basis')}">
                        <xsl:sequence select="$basis-body"/>
                        <xs:attribute name="entiteittype" type="{concat($prefix,':Entiteittype',imvert:alias)}" use="prohibited"/>
                        <xsl:if test="not($is-subtype)">
                            <xs:attributeGroup ref="StUF:entiteit"/>
                        </xsl:if>
                    </xs:restriction>
                </xs:complexContent>    
            </xs:complexType>
        </xsl:if>

        <xsl:if test="$is-subtype and exists($superclasses[2])">
            <xsl:sequence select="imf:msg(.,'ERROR','Unable to define subtype for multiple supertypes: [1]',string-join($superclasses[1]/imvert:name/@original,', '))"/>
        </xsl:if>
        
        <xsl:if test="$is-subtype">
            <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype is subtype # ',imvert:name/@original))"/>
            <xs:complexType name="{imvert:alias}-basis">
                <xsl:sequence select="imf:create-annotation(.)"/>
                <xs:complexContent>
                    <xs:extension base="{concat($prefix,':',$superclasses[1]/imvert:alias,'-abstract')}">
                        <xsl:sequence select="$basis-body"/>
                        <xs:attribute name="entiteittype" type="{concat($prefix,':Entiteittype',imvert:alias)}"/>
                    </xs:extension>
                </xs:complexContent>
            </xs:complexType>
            <xs:simpleType name="{concat('Entiteittype',imvert:alias)}">
                <xs:restriction base="string">
                    <xs:enumeration value="{imvert:alias}"/>
                </xs:restriction>
            </xs:simpleType>
        </xsl:if>
        
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-kerngegevens">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="kerngegevens" select="imvert:*/imvert:*[imf:boolean(imvert:is-id)]"/> <!-- attributes and associations. -->
        
        <xsl:variable name="superclasses" select="imf:get-superclasses(.)"/>
        <xsl:variable name="is-subtype" select="exists($superclasses)"/>
        <xsl:variable name="is-abstract" select="imf:boolean(imvert:abstract)"/>
        
        <xsl:variable name="body-kern">
            <xs:sequence>
                <xsl:for-each select="$kerngegevens">
                    <xsl:choose>
                        <xsl:when test="self::imvert:attribute">
                            <xsl:apply-templates select="." mode="mode-local-attribute"/>
                        </xsl:when>
                        <xsl:when test="self::imvert:association[imvert:aggregation = 'composite']">
                            <xsl:apply-templates select="." mode="mode-local-composition">
                                <xsl:with-param name="kerngegevens" select="true()"/>
                            </xsl:apply-templates>
                        </xsl:when>
                        <xsl:when test="self::imvert:association[not(imvert:aggregation = 'composite')]">
                            <xsl:apply-templates select="." mode="mode-local-association">
                                <xsl:with-param name="kerngegevens" select="true()"/>
                                <xsl:with-param name="richting" select="'uitgaand'"/>
                            </xsl:apply-templates>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:sequence select="."/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xs:sequence>
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="$is-abstract">
                <!-- geen kerngegevens -->
                <xsl:sequence select="imf:create-comment(concat('mode-global-kerngegevens Kerngegevens abstract niet gegenereerd # ',@display-name))"/>
            </xsl:when>
            <!-- TODO moet er onderscheid worden gemaakt tussen gewoon en subtype? -->
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('mode-global-kerngegevens Kerngegevens # ',@display-name))"/>
                
                <xs:complexType name="{imvert:alias}-kerngegevens">
                    <xs:complexContent>
                        <xs:restriction base="{concat($prefix,':', imvert:alias,'-basis')}">
                            <xsl:sequence select="$body-kern"/>
                            <xs:attribute name="entiteittype" use="required" type="{concat($prefix, ':Entiteittype', imvert:alias)}"/>
                            <xs:attribute ref="StUF:sleutelVerzendend"/>
                            <xs:attribute ref="StUF:sleutelOntvangend"/>
                            <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                            <xs:attribute ref="StUF:noValue" use="prohibited"/>
                            <xs:attribute ref="StUF:scope" use="prohibited"/>
                            <xs:attribute ref="StUF:verwerkingssoort"/>
                        </xs:restriction>
                    </xs:complexContent>
                </xs:complexType>
                
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <!-- Groepsattribuutsoort -->
    <xsl:template match="imvert:class" mode="mode-global-gegevensgroeptype">
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-gegevensgroeptype Groepsattribuutsoort # ',@display-name))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:sequence>
                <xsl:sequence select="imf:create-comment('mode-global-gegevensgroeptype (Attributes)')"/>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>
                <xsl:sequence select="imf:create-comment('mode-global-gegevensgroeptype (Groepen)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[imvert:aggregation = 'composite']" mode="mode-local-composition"/>
                <xsl:sequence select="imf:create-comment('mode-global-gegevensgroeptype (Associations)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[not(imvert:aggregation = 'composite')]" mode="mode-local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
                
                <?mogelijk-vervallen 
                <xsl:variable name="inkomende-associaties" select="$document//imvert:association[imf:get-type-id(.) = $id]"/>
                <xsl:apply-templates select="$inkomende-associaties" mode="mode-local-association">
                    <xsl:with-param name="richting">inkomend</xsl:with-param>
                </xsl:apply-templates>
                ?>
                
            </xs:sequence>
        </xs:complexType>
    </xsl:template>
    
    
    <xsl:template match="imvert:class" mode="mode-global-complextype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-complextype Complextype # ',imvert:name/@original))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:sequence>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-data-element"/>
            </xs:sequence>
        </xs:complexType>
        
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-referentielijst">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-referentielijst Referentelijst # ',@display-name))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}-basis">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:sequence>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-referentielijst-element"/>
                <xs:element ref="StUF:tijdvakObject" minOccurs="0"/>
                <xs:element ref="StUF:tijdvakGeldigheid" minOccurs="0"/><!-- TODO wanneer opnemen? -->
                <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                <xs:element ref="StUF:aanvullendeElementen" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="entiteittype" type="{concat($prefix, ':Entiteittype', $compiled-name)}"/>
            <xs:attribute ref="StUF:scope"/>
            <xs:attribute ref="StUF:verwerkingssoort"/> 
        </xs:complexType>
        
        <xs:simpleType name="{concat('Entiteittype',$compiled-name)}">
            <xs:restriction base="string">
                <xs:enumeration value="{imvert:alias}"/>
            </xs:restriction>
        </xs:simpleType>
        
    </xsl:template>
    
    <?x
    <xsl:template match="imvert:class" mode="mode-global-enumeration">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-enumeration Enumeration # ',imvert:name/@original))"/>
        
        <xs:simpleType name="{imf:capitalize($compiled-name)}">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:restriction base="xs:string">
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-enum"/>
            </xs:restriction>
        </xs:simpleType>
        
    </xsl:template>
    ?>
    
    <xsl:template match="imvert:class" mode="mode-global-union">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-union Union # ',imvert:name/@original))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:choice>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-union-element"/>
            </xs:choice>
        </xs:complexType>
        
    </xsl:template>
    
    
    <!-- LOCAL SUBSTRUCTURES -->
    
    <xsl:template match="imvert:attribute" mode="mode-local-attribute">
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
        
        <xsl:variable name="is-in-onderzoek" select="imf:is-in-onderzoek(.)"/>
        
        <xsl:variable name="type-is-datatype" select="$type/imvert:designation = 'datatype'"/>
        <xsl:variable name="type-is-complextype" select="$type-is-datatype and $type/imvert:stereotype = imf:get-config-stereotypes('stereotype-name-complextype')"/>
        <xsl:variable name="type-is-simpletype" select="$type-is-datatype"/>
    
        <xsl:variable name="type-is-referentietabel" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-referentielijst')"/>
        <xsl:variable name="type-is-enumeration" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-enumeration')"/>
        
        <xsl:variable name="type-is-external" select="exists(imvert:conceptual-schema-type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-attribute Local attribute # ',@display-name))"/>

        <xsl:variable name="scalar-att-type" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:choose>
            <xsl:when test="exists($scalar-att-type)">
                <!-- 
                    Als het metagegeven Element.formaat gelijk is aan één van de waarden in onderstaande 
                    tabel  dan wordt er alleen een element gecreëerd omdat er gebruik kan worden gemaakt van een 
                    bestaande complex type uit de StUF-onderlaag (zie ‘stuf0302.xsd’) 
                -->
                <xsl:sequence select="imf:create-comment('Scalar in de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{$scalar-att-type}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            
            <xsl:when test="$type-is-referentietabel">
                <xsl:sequence select="imf:create-comment('Een referentie tabel')"/>
                <!-- we moeten hier het type van de is-ID van de target opnemen -->
                <xsl:variable name="tabel-id-attribute" select="$type//imvert:attribute[imvert:is-id = 'true']"/>
                
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize(imf:get-compiled-name($tabel-id-attribute)))}"
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            
            <xsl:when test="$type-is-enumeration">
                <xsl:sequence select="imf:create-comment('Een enumeratie')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name))}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            
            <xsl:when test="$type-is-complextype">
                <xsl:sequence select="imf:create-comment('Een complex datatype')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name), '-e')}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            
            <xsl:when test="$type-is-simpletype">
                <xsl:sequence select="imf:create-comment('Een simpel datatype')"/> 
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name),'-e')}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            
            <xsl:when test="$type-is-external">
                <xsl:sequence select="imf:create-comment('Een extern type')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{imf:get-external-type-name(.,true())}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment('Scalar maar niet in de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name),'-e')}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:otherwise>
        </xsl:choose>
     
    </xsl:template>
    
    <xsl:function name="imf:get-external-type-name">
        <xsl:param name="attribute"/>
        <xsl:param name="as-type" as="xs:boolean"/>
        <!-- determine the name; hard koderen -->
        <xsl:for-each select="$attribute"> <!-- singleton -->
            <xsl:choose>
                <xsl:when test="imvert:type-package='GML3'">
                    <xsl:variable name="type-suffix" select="if ($as-type) then 'Type' else ''"/>
                    <xsl:variable name="type-prefix">
                        <xsl:choose>
                            <xsl:when test="empty(imvert:conceptual-schema-type)">
                                <xsl:sequence select="imf:msg(.,'ERROR','No conceptual schema type specified',())"/>
                            </xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Point'">gml:Point</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Curve'">gml:Curve</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Surface'">gml:Surface</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiPoint'">gml:MultiPoint</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiSurface'">gml:MultiSurface</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiCurve'">gml:MultiCurve</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Geometry'">gml:Geometry</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiGeometry'">gml:MultiGeometry</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_ArcString'">gml:ArcString</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_LineString'">gml:LineString</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Polygon'">gml:Polygon</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Object'">gml:Geometry</xsl:when><!-- see http://www.geonovum.nl/onderwerpen/geography-markup-language-gml/documenten/handreiking-geometrie-model-en-gml-10 -->
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Primitive'">gml:Primitive</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Position'">gml:Position</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_PointArray'">gml:PointArray</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Solid'">gml:Solid</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_OrientableCurve'">gml:OrientableCurve</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_OrientableSurface'">gml:OrientableSurface</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_CompositePoint'">gml:CompositePoint</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiSolid'">gml:MultiSolid</xsl:when>
                            <xsl:otherwise>
                                <xsl:sequence select="imf:msg(.,'ERROR','Cannot handle the GML type [1]', imvert:conceptual-schema-type)"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:value-of select="concat($type-prefix,$type-suffix)"/>
               </xsl:when>
                <xsl:when test="empty(imvert:type-package)">
                    <!-- TODO -->
                </xsl:when>
                <xsl:otherwise>
                    <!-- geen andere externe packages bekend -->
                    <xsl:sequence select="imf:msg(.,'ERROR','Cannot handle the external package [1]', imvert:type-package)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
        
    </xsl:function>
    
    <xsl:template match="imvert:attribute" mode="mode-local-data-element">
        <xsl:apply-templates select="." mode="mode-local-attribute"/>
        <?x
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-data-element Local data element # ',@display-name))"/>
        
        <xsl:variable name="stuf-scalar-att-type" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:choose>
            <xsl:when test="exists($stuf-scalar-att-type)">
                <xsl:sequence select="imf:create-comment('In de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{$stuf-scalar-att-type}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                />
            </xsl:when>
            <xsl:when test="empty($type)">
                <xsl:sequence select="imf:create-comment('Simple type, niet in de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name))}-e" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
                
            </xsl:when>
            <xsl:when test="$type[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-enumeration')]">
                <xsl:sequence select="imf:create-comment('Enumeratie')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name-type))}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                     >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
                
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment('Niet simpel datatype, niet in de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name-type),'-e')}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:otherwise>
        </xsl:choose>
        ?>
        
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-local-enum">
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-attribute Local enum # ',@display-name))"/>
        
        <xs:enumeration value="{imvert:name}">
            <xsl:sequence select="imf:create-annotation(.)"/>
        </xs:enumeration>
        
    </xsl:template>

    <!-- de weergave van een enkele keuze -->
    <xsl:template match="imvert:attribute" mode="mode-local-union-element">
        <xsl:apply-templates select="." mode="mode-local-attribute"/>
        <?x
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-is-external" select="exists(imvert:conceptual-schema-type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-union-element Local union element # ',@display-name))"/>
        
        <xsl:variable name="type-ref">
            <xsl:choose>
                <xsl:when test="$type-is-external">
                    <xsl:value-of select="imf:get-external-type-name(.,false())"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="imf:get-compiled-name($type)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xs:element
            ref="{$type-ref}" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
        />
        ?>
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-local-referentielijst-element">
        <xsl:apply-templates select="." mode="mode-local-attribute"/>
        <?x
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-attribute Local referentielijst element # ',@display-name))"/>
        
        <xs:element
            name="{$compiled-name}" 
            type="{concat($prefix, ':', imf:capitalize($compiled-name),'-e')}" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
        />
        ?>
        
    </xsl:template>
    
    <!-- dit betreft echte relaties, dus geen composities -->
    <xsl:template match="imvert:association" mode="mode-local-association">
        <xsl:param name="kerngegevens" select="false()"/>
        <xsl:param name="richting" select="'uitgaand'"/>
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert:class"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        
        <xsl:choose>
            <xsl:when test="$richting = 'uitgaand'">
                <xsl:sequence select="imf:create-comment(concat('mode-local-association Uitgaande relatie # ',@display-name))"/>
                
                <xsl:variable name="heen-typeref" select="concat($prefix, ':', imvert:alias,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="target-cardinality" select="if ($history[2]) then 'unbounded' else $cardinality[4]"/> <!-- als materiele historie, dan is target altijd unbounded -->
                <xs:element
                    name="{imvert:name}" 
                    type="{$heen-typeref}" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            <?mogelijk-vervallen
            <xsl:when test="imf:boolean(imf:get-taggedvalue(.,'Relatiesoort terugrelatie'))">
                <xsl:sequence select="imf:insert-comment(concat('mode-local-association Inkomende relatie ',@display-name))"/>
                
                <xsl:variable name="associatie-naam" select="imf:get-taggedvalue(.,'Mnemonic relatiesoort terugrelatie')"/>
                <xsl:variable name="terug-typeref" select="concat($prefix, ':',$associatie-naam ,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="target-cardinality" select="if ($history[2]) then 'unbounded' else $cardinality[2]"/> <!-- als materiele historie, dan is target altijd unbounded -->
                <xs:element
                    name="{concat($source/imvert:alias,imf:get-relation-suffix($source)[1])}" 
                    type="{$terug-typeref}" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            ?>
            <xsl:otherwise>
               <!-- er hoeft geen terugrelatie te worden gegenereerd -->
            </xsl:otherwise>
        </xsl:choose>
    
    </xsl:template>
    
    <!-- dit betreft gegevensgroepen, dus composities -->
    <xsl:template match="imvert:association" mode="mode-local-composition">
        <xsl:param name="kerngegevens" select="false()"/>

        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-composition Association # ',@display-name))"/>
        
        <xs:element
            name="{$compiled-name}" 
            type="{concat($prefix, ':', $compiled-name-type)}" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
            >
            <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
        </xs:element>
        
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-type">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-stereotype" select="imf:get-stereotype($type)"/>
        <xsl:variable name="stuf-scalar-att-type" select="imf:get-stuf-scalar-attribute-type(.)"/>
        <xsl:variable name="is-enumeration" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-enumeration')"/>
        
        <xsl:choose>
            <xsl:when test="$is-enumeration">
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-type Enumeration # ',imvert:name/@original))"/>
                <xs:simpleType name="{imf:capitalize($compiled-name)}">
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xs:restriction base="xs:string">
                        <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-enum"/>
                    </xs:restriction>
                </xs:simpleType>
            </xsl:when>
            <xsl:when test="empty($stuf-scalar-att-type)">
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-type Attribute declaration # ',@display-name))"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}-e">
                    <xs:choice>
                        <xs:element name="w" type="{$prefix}:{imf:capitalize($compiled-name)}"/>
                        <xs:element name="l" type="StUF:NoValue"/>
                    </xs:choice>
                </xs:complexType>
                <xs:complexType name="{imf:capitalize($compiled-name)}-s">
                    <xs:choice>
                        <xs:element name="w" type="{$prefix}:{imf:capitalize($compiled-name)}-w"/>
                    </xs:choice>
                </xs:complexType>
                <xs:complexType name="{imf:capitalize($compiled-name)}-w">
                    <xsl:choose>
                        <xsl:when test="empty($type)">
                            <xs:simpleContent>
                                <xs:extension base="{$prefix}:{imf:capitalize($compiled-name)}">
                                    <xs:attribute ref="StUF:wildcard"/>    
                                </xs:extension>
                            </xs:simpleContent>
                        </xsl:when>
                        <xsl:otherwise>
                            <xs:complexContent>
                                <xs:extension base="{$prefix}:{imf:capitalize($compiled-name)}">
                                    <xs:attribute ref="StUF:wildcard"/>    
                                </xs:extension>
                            </xs:complexContent>
                        </xsl:otherwise>
                    </xsl:choose>
                </xs:complexType>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-type Attribute is in onderlaag # ',@display-name))"/>
            </xsl:otherwise>
        </xsl:choose>
            
    </xsl:template>
    
    <xsl:template match="imvert:association" mode="mode-global-association-type">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert:class"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        
        <xsl:variable name="hisform-on-association" select="imf:get-history(.)[1]"/>
        <xsl:variable name="hismate-on-association" select="imf:get-history(.)[2]"/>
        
        <xsl:variable name="association-class" select="imf:get-by-id(imvert:association-class/imvert:type-id)"/>
        <xsl:variable name="association-class-attributes" select="$association-class//imvert:attribute"/>
        <xsl:variable name="association-class-associations" select="$association-class//imvert:association"/>
       
        <xsl:variable name="hisform-on-association-class" select="imf:get-history($association-class)[1]"/>
        <xsl:variable name="hismate-on-association-class" select="imf:get-history($association-class)[2]"/>
        
        <xsl:variable name="suffix" select="imf:get-relation-suffix(.)"/>
        
        <xsl:variable name="source-alias" select="imvert:source-alias"/>
        <xsl:variable name="target-alias" select="imvert:target-alias"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-association-type Outgoing Association declaration # ',@display-name))"/>
    
        <xsl:variable name="associatie-naam" select="imvert:alias"/>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:choice>
                <xs:element ref="StUF:leeg"/>
                <xs:sequence>
                    <xs:element 
                        name="gerelateerde" 
                        type="{$prefix}:{$target/imvert:alias}-basis"
                        minOccurs="0"/>
                    
                    <!-- add the attributes & associations of the association class, if any -->
                    <xsl:apply-templates select="$association-class-attributes" mode="mode-local-attribute"/>
                    
                    <!-- als er is materiele historie is op de relatie -->
                    <xsl:if test="exists($hismate-on-association)">
                        <xs:element ref="StUF:tijdvakRelatie" minOccurs="0"/>                        
                    </xsl:if>     
                    <!-- als er een associatieklasse is en als er histore op zit op een of meer van de elementen daarvan -->
                    <xsl:if test="exists($hisform-on-association-class) or exists($hismate-on-association-class)">
                        <xs:element ref="StUF:tijdvakGeldigheid" minOccurs="0"/>     
                    </xsl:if>
                    <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                    <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                    <xs:element ref="StUF:aanvullendeElementen" minOccurs="0"/>
                    <xsl:if test="exists($association-class) and $hismate-on-association">
                        <xs:element name ="historieMaterieel" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                            minOccurs="0"     
                            maxOccurs="unbounded"/>
                    </xsl:if>
                    <xsl:if test="exists($association-class) and $hisform-on-association">
                        <xs:element name="historieFormeel" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                            minOccurs="0"/>  
                    </xsl:if>
                    <xsl:if test="empty($association-class) and $hisform-on-association">
                        <xs:element name="historieFormeelRelatie" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                            minOccurs="0"/>  
                    </xsl:if>
                   
                    <xsl:apply-templates select="$association-class-associations" mode="mode-local-associations"/>
         
                </xs:sequence>
            </xs:choice>
            <xs:attribute name="entiteittype" type="{concat($prefix, ':Entiteittype', imvert:alias)}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
        
        <xs:simpleType name="{concat('Entiteittype',imvert:alias)}">
            <xs:restriction base="string">
                <xs:enumeration value="{imvert:alias}"/>
            </xs:restriction>
        </xs:simpleType>
        
        <xsl:if test="exists(imvert:is-id)">
            <xsl:sequence select="imf:create-comment(concat('mode-global-association-type Outgoing Association kerngegevens # ',@display-name))"/>
            
            <xs:complexType name="{$associatie-naam}-kerngegevens">
                <xs:annotation>
                    <xs:documentation>Kerngegevens van de relatie</xs:documentation>
                </xs:annotation>
                <xs:complexContent>
                    <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                        <xs:sequence>
                            <xs:element 
                                name="gerelateerde" 
                                type="{$prefix}:{$target/imvert:alias}-kerngegevens"
                                minOccurs="0"/>
                        </xs:sequence>
                        <xs:attribute name="entiteittype" use="required" type="{concat($prefix, ':Entiteittype', imvert:alias)}"/>
                        <xs:attributeGroup ref="StUF:entiteit"/>
                    </xs:restriction>
                </xs:complexContent>
            </xs:complexType>
        </xsl:if>
        
        <?mogelijk-vervallen
        <xsl:sequence select="imf:insert-comment(concat('mode-global-association-type Incoming Association declaration ',@display-name))"/>
        
        <xsl:variable name="associatie-naam" select="imf:get-taggedvalue(.,'Mnemonic relatiesoort terugrelatie')"/>
        <xsl:if test="not(normalize-space($associatie-naam))">
            <xsl:value-of select="imf:msg(.,'ERROR','No Menomonic specified for terugrelatie',())"/>
        </xsl:if>
        
        <xsl:variable name="original-incoming" select="imf:get-taggedvalue(.,'Naam terugrelatie')"/>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xs:sequence>
                <xs:element 
                    name="gerelateerde" 
                    type="{$prefix}:{$source/imvert:alias}-basis"
                    minOccurs="0"/>
                
                <!-- add the attributes of the association class, if any -->
                <xsl:apply-templates select="$association-class-attributes" mode="mode-local-attribute"/>
                
                <xs:element ref="StUF:tijdvakRelatie" minOccurs="0"/>
                
                <xs:element 
                    ref="StUF:extraElementen" 
                    minOccurs="0"/>
                     <xs:element ref="StUF:aanvullendeElementen" minOccurs="0"/>
                
                <xsl:if test="exists($association-class) and $hismate-on-association">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="exists($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
                <xsl:if test="empty($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeelRelatie" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" fixed="{$associatie-naam}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
    
        <xsl:sequence select="imf:insert-comment(concat('mode-global-association-type Incoming Association kerngegevens ',@display-name))"/>
        
        <xs:complexType name="{$associatie-naam}-kerngegevens">
            <xs:annotation>
                <xs:documentation>Kerngegevens van de relatie</xs:documentation>
            </xs:annotation>
            <xs:complexContent>
                <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                    <xs:sequence>
                        <xs:element 
                            name="gerelateerde" 
                            type="{$prefix}:{$source/imvert:alias}-kerngegevens"
                            minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$associatie-naam}"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
        
        ?>
  
    </xsl:template>
    
    <!-- called only with attributes that have no type-id -->
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-simpletype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="stuf-scalar" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:variable name="max-length" select="imvert:max-length"/>
        <xsl:variable name="total-digits" select="imvert:total-digits"/>
        <xsl:variable name="fraction-digits" select="imvert:fraction-digits"/>
        
        <xsl:variable name="min-waarde" select="imf:get-taggedvalue(.,'Minimum waarde (inclusief)')"/>
        <xsl:variable name="max-waarde" select="imf:get-taggedvalue(.,'Maximum waarde (inclusief)')"/>
        <xsl:variable name="min-length" select="imf:get-taggedvalue(.,'Minimum lengte')"/>
        <xsl:variable name="patroon" select="imf:get-taggedvalue(.,'Formeel patroon')"/>
        
        <xsl:variable name="facetten">
            <xsl:sequence select="imf:create-facet('xs:pattern',$patroon)"/>
            <xsl:sequence select="imf:create-facet('xs:minInclusive',$min-waarde)"/>
            <xsl:sequence select="imf:create-facet('xs:maxInclusive',$max-waarde)"/>
            <xsl:sequence select="imf:create-facet('xs:minLength',$min-length)"/>
            <xsl:sequence select="imf:create-facet('xs:maxLength',$max-length)"/>
            <xsl:sequence select="imf:create-facet('xs:totalDigits',$total-digits)"/>
            <xsl:sequence select="imf:create-facet('xs:fractionDigits',$fraction-digits)"/>
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="exists($stuf-scalar)">
                <!-- gedefinieerd in onderlaag -->
            </xsl:when>
            <xsl:when test="exists(imvert:type-name)">
                
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-simpletype Attribuut type (simple) # ',@display-name))"/>
                
                <xs:simpleType name="{imf:capitalize($compiled-name)}">
                    <xsl:choose>
                        <xsl:when test="imvert:type-name = 'scalar-integer'">
                            <xs:restriction base="xs:integer">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-string'">
                            <xs:restriction base="xs:string">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-decimal'">
                            <xs:restriction base="xs:decimal">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-boolean'">
                            <xs:restriction base="xs:boolean">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-date'">
                            <xs:restriction base="xs:dateTime">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-txt'">
                            <xs:restriction base="xs:string">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>    
                        <xsl:when test="imvert:type-name = 'scalar-uri'">
                            <xs:restriction base="xs:anyURI">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-indic'">
                            <xs:restriction base="xs:boolean"/>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-postcode'">
                            <xs:restriction base="StUF:postcode">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:sequence select="imf:msg(.,'ERROR','Cannot handle the simple attribute type: [1]', imvert:type-name)"/>
                        </xsl:otherwise>                
                    </xsl:choose>
                </xs:simpleType>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    
    <!-- called only with attributes that have a type-id -->
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-niet-simpletype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-stereo" select="imf:get-stereotype($type)"/>
        <xsl:variable name="compiled-type-name" select="imf:get-compiled-name($type)"/>
        
        <xsl:variable name="type-is-complextype" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-complextype')"/>
        <xsl:variable name="type-is-referentietabel" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-referentielijst')"/>
        <xsl:variable name="type-is-enumeration" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-enumeration')"/>
        <xsl:variable name="type-is-union" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-union')"/>
        <xsl:variable name="type-is-interface" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-interface')"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-niet-simpletype Attribuut type (not simple) # ',@display-name))"/>
        
        <xsl:choose>
            <xsl:when test="$type-is-complextype">
                <xsl:sequence select="imf:create-comment('Type is complex datatype')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name))}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <xsl:when test="$type-is-referentietabel">
                <xsl:sequence select="imf:create-comment('Type is referentie tabel')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name),'-basis')}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <xsl:when test="$type-is-enumeration">
                <xsl:sequence select="imf:create-comment('Type is enumeration - skipped.')"/>
            </xsl:when>
            <xsl:when test="$type-is-union">
                <xsl:sequence select="imf:create-comment('Type is union')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name))}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <xsl:when test="$type-is-interface">
                <xsl:sequence select="imf:create-comment('TODO Type is interface')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{imf:get-external-type-name(.,true())}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('TODO Geen bekend type: ',$type-stereo))"/>
            </xsl:otherwise>
        </xsl:choose>
         
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-referentieelement">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="stuf-scalar" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:choose>
            <xsl:when test="exists($stuf-scalar)">
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-referentieelement Referentie element 1 # ',imvert:name/@original))"/>
       
                <xs:simpleType name="{concat(imf:capitalize($compiled-name),'-e')}">
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xs:restriction base="{$stuf-scalar}"/>
                </xs:simpleType>
                
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-referentieelement Referentie element 2 # ',imvert:name/@original))"/>
                
                <xs:complexType name="{concat(imf:capitalize($compiled-name),'-e')}">
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xs:simpleContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-name))}">
                            <xs:attributeGroup ref="StUF:element"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template>
      
    <xsl:function name="imf:get-compiled-name">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="type" select="local-name($this)"/>
        <xsl:variable name="stereotype" select="imf:get-stereotype($this)"/>
        <xsl:variable name="alias" select="$this/imvert:alias"/>
        <xsl:variable name="name-raw" select="$this/imvert:name"/>
        <xsl:variable name="name" select="replace($name-raw,'[^\p{L}0-9.\-]+','_')"/>
        <xsl:choose>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-composite')">
                <xsl:value-of select="concat(imf:capitalize($name),'Grp')"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-objecttype')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-relatieklasse')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-referentielijst')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-complextype')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-enumeration')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-union')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-interface')">
                <!-- this must be an external -->
                <xsl:variable name="external-name" select="imf:get-external-type-name($this,true())"/>
                <xsl:value-of select="$external-name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-attribute')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-referentieelement')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-data-element')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-enum')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-union-element')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $stereotype = 'relatiesoort' and normalize-space($alias)">
                <!-- if this relation occurs multiple times, add the alias of the target object -->
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $this/imvert:aggregation = 'composite'">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $stereotype = 'relatiesoort'">
                <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                <xsl:value-of select="lower-case($name)"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and normalize-space($alias)"> <!-- composite -->
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'association'">
                <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                <xsl:value-of select="lower-case($name)"/>
            </xsl:when>
            <!-- TODO meer soorten namen uitwerken? -->
            <xsl:otherwise>
                <xsl:sequence select="imf:msg($this,'ERROR','Unknown type [1] with stereo [2]', ($type, string-join($stereotype,', ')))"/>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="imf:get-cardinality" as="xs:string+">
        <xsl:param name="this"/>
        <xsl:variable name="source-min" select="$this/imvert:min-occurs-source"/>
        <xsl:variable name="source-max" select="$this/imvert:max-occurs-source"/>
        <xsl:variable name="target-min" select="$this/imvert:min-occurs"/>
        <xsl:variable name="target-max" select="$this/imvert:max-occurs"/>
        <xsl:sequence select="(normalize-space($source-min),normalize-space($source-max),normalize-space($target-min),normalize-space($target-max))"/>
    </xsl:function>
    
    <!-- 
        return (formal?, material?) boolean values 
    
        if this is a composition to a group, inspect the group history 
    -->
    <xsl:function name="imf:get-history" as="xs:boolean+">
        <xsl:param name="this"/>
        <xsl:variable name="formal-this" select="imf:get-taggedvalue($this,'Indicatie formele historie')"/>
        <xsl:variable name="formal-grp" select="imf:get-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie formele historie')"/>
        <xsl:variable name="formal" select="if ($formal-this = 'zie groep') then $formal-grp else $formal-this"/>
        <xsl:variable name="material-this" select="imf:get-taggedvalue($this,'Indicatie materiële historie')"/>
        <xsl:variable name="material-grp" select="imf:get-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie materiële historie')"/>
        <xsl:variable name="material" select="if ($material-this = 'zie groep') then $material-grp else $material-this"/>
        <xsl:sequence select="(imf:boolean($this,$formal),imf:boolean($this,$material))"/>
    </xsl:function>

    <xsl:function name="imf:get-stereotype" as="xs:string*">
        <xsl:param name="this"/>
        <xsl:sequence select="$this/imvert:stereotype"/>
    </xsl:function>

    <xsl:function name="imf:get-taggedvalue" as="xs:string?">
        <xsl:param name="this"/>
        <xsl:param name="name"/>
        <xsl:value-of select="$this/imvert:tagged-values/imvert:tagged-value[imvert:name = $name]/imvert:value"/>
    </xsl:function>
    
    <xsl:function name="imf:get-groepattribuutsoort" as="element()?">
        <xsl:param name="this" as="element()"/>
        <xsl:sequence select="$this/ancestor-or-self::imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-composite')]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-documentation">
        <xsl:param name="this"/>
        <xsl:value-of select="normalize-space($this/imvert:documentation)"/>
    </xsl:function>
    
    <!-- tools -->
    
    <xsl:function name="imf:capitalize">
        <xsl:param name="name"/>
        <xsl:value-of select="concat(upper-case(substring($name,1,1)),substring($name,2))"/>
    </xsl:function>
    
    <xsl:function name="imf:boolean" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:param name="value"/>
        <xsl:sequence select="$value eq 'Ja'"/>
    </xsl:function>

    <!-- 
        ============================================== 
        common for all model based stylesheets 
        ============================================== 
    -->
    
    <xsl:function name="imf:get-construct-name" as="item()*">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="name" select="imf:sub-name($this)"/>
        <xsl:variable name="package-name" select="imf:sub-name($this/ancestor-or-self::imvert:package[1])"/>
        <xsl:variable name="class-name" select="imf:sub-name($this/ancestor-or-self::imvert:class[1])"/>
        <xsl:choose>
            <xsl:when test="$this/self::imvert:package">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:base">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:class">
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:type">
                <xsl:sequence select="imf:compile-construct-name($this/imvert:type-package,$this/imvert:type-name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:attribute">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'attrib')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:association[not(imf:sub-name(.))]">
                <xsl:variable name="type" select="concat('[',$this/imvert:type-name,']')"/>
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$type,'aggr')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:association">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'assoc')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,local-name($this),'')"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="imf:sub-name">
        <xsl:param name="this"/>
        <xsl:value-of select="$this/imvert:name"/>
    </xsl:function>

    <xsl:function name="imf:get-class" as="element()?">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:type-id"/>
        <xsl:if test="normalize-space($id)">
            <xsl:variable name="class" select="root($this)//imvert:class[imf:get-id(.) = $id]"/>
            <xsl:sequence select="$class"/>
        </xsl:if>
    </xsl:function>

    <xsl:function name="imf:stub-create-name">
        <xsl:param name="literal-name"/>
        <xsl:value-of select="concat('STUB-',replace($literal-name,'[^a-zA-Z]','_'))"/>
    </xsl:function>

    <xsl:function name="imf:parse-names" as="xs:string*">
        <xsl:param name="text" as="xs:string"/>
        <xsl:analyze-string select="$text" regex="'(.+?)'">
            <xsl:matching-substring>
                <xsl:value-of select="regex-group(1)"/>
            </xsl:matching-substring>
        </xsl:analyze-string>
    </xsl:function>
    
    <xsl:function name="imf:get-by-id" as="element()?">
        <xsl:param name="id"/>
        <xsl:sequence select="$document//*[imf:get-id(.) = $id]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- get the ID of the type of the attribute or association -->
    <xsl:function name="imf:get-type-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:type-id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- return suffixes to append to relation names. [1] is incoming, [2] is outgoing -->
    <xsl:function name="imf:get-relation-suffix" as="xs:string+">
        <xsl:param name="this"/> <!-- an Association element -->
        <xsl:variable name="targetAlias" select="$this/imvert:target-alias"/>
        <xsl:variable name="targetId" select="imf:get-type-id($this)"/>
        
        <xsl:variable name="other-associations" select="root($this)//imvert:association[imvert:target-alias = $targetAlias and imf:get-type-id(.) = $targetId]"/>
        <xsl:variable name="class" select="$this/ancestor::imvert:class"/>
        <xsl:value-of select="if (count($other-associations) gt 1) then imf:capitalize($class/imvert:name) else ''"/>

        <xsl:variable name="class" select="root($this)//imvert:class[imf:get-id(.) = $targetId]"/>
        <xsl:value-of select="if (count($this/../imvert:association[imvert:target-alias = $targetAlias]) gt 1) then imf:capitalize($class/imvert:name) else ''"/>

    </xsl:function>
    
    <xsl:function name="imf:create-annotation">
        <xsl:param name="this"/>
        <xs:annotation>
            <xs:documentation>
                <xsl:value-of select="concat($this/imvert:name/@original, ': ', imf:get-documentation($this))"/>
            </xs:documentation>
        </xs:annotation>
    </xsl:function>
    
    <!-- deze scalars kunnen meteen uit de StUF onderlaag worden gehaald -->
    <xsl:function name="imf:get-stuf-scalar-attribute-type" as="xs:string?">
        <xsl:param name="attribute"/>
   
        <xsl:choose>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-date'">
                <xsl:value-of select="'StUF:MogelijkOnvolledigeDatum-e'"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-datetime'">
                <xsl:value-of select="'StUF:MogelijkOnvolledigeDatumTijd-e'"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-year'">
                <xsl:value-of select="'StUF:Jaar-e'"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-yearmonth'">
                <xsl:value-of select="'StUF:JaarMaand-e'"/>
            </xsl:when>
        </xsl:choose>
    
    </xsl:function>
    
    <xsl:function name="imf:create-comment" as="comment()?">
        <xsl:param name="text"/>
        <xsl:if test="$debugging">
            <xsl:comment select="$text"/>
        </xsl:if>
    </xsl:function>
    
    <xsl:function name="imf:create-facet" as="element()?">
        <xsl:param name="elementname"/>
        <xsl:param name="content"/>
        <xsl:if test="normalize-space($content)">
            <xsl:element name="{$elementname}">
                <xsl:attribute name="value" select="$content"/>
            </xsl:element>
        </xsl:if>
    </xsl:function>
    
    <xsl:function name="imf:get-external-element-name">
        <xsl:param name="conceptual-schema-namespace"/>
        <xsl:param name="conceptual-schema-class-name"/>
        
    </xsl:function>
    
    <xsl:function name="imf:is-in-onderzoek" as="xs:boolean">
        <xsl:param name="construct"/>
        <xsl:variable name="tv" select="imf:get-most-relevant-compiled-taggedvalue($construct,'IndicatieInOnderzoek')"/>
        <xsl:sequence select="imf:boolean($tv)"/>
    </xsl:function>
    
    <xsl:function name="imf:create-historie-attributes" as="attribute()*">
        <xsl:param name="formeel"/>
        <xsl:param name="materieel"/>
        <xsl:if test="imf:boolean($formeel)">
            <xsl:attribute name="metadata:formeleHistorie" select="$formeel"/>
        </xsl:if>
        <xsl:if test="imf:boolean($materieel)">
            <xsl:attribute name="metadata:materieleHistorie" select="$materieel"/>
        </xsl:if>
    </xsl:function>
    
    <!-- =================== cleanup =================== -->
   
    <?x <xsl:template match="xs:schema" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:variable name="names" select="for $n in (xs:*/@name) return string($n)" as="xs:string*"/>
            <xsl:variable name="names-dup" select="distinct-values($names[count(index-of($names,.)) gt 1])"/>
            <xsl:apply-templates mode="xsd-cleanup">
                <xsl:with-param name="names-dup" select="$names-dup"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="xs:complexType | xs:simpleType" mode="xsd-cleanup">
        <xsl:param name="names-dup"/>
        <xsl:variable name="name" select="@name"/>
        <xsl:choose>
            <xsl:when test="($name = $names-dup) and (preceding-sibling::xs:*/@name = $name)">
                <xsl:sequence select="imf:create-comment(concat('xsd-cleanup Duplicate removed', ()))"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>?>
    
    <xsl:template match="*" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="xsd-cleanup"/>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="comment()" mode="xsd-cleanup">
        <xsl:if test="$allow-comments-in-schema">
            <xsl:sequence select="."/>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="imvert:dummy"/>
</xsl:stylesheet>
