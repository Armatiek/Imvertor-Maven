<?xml version="1.0" encoding="UTF-8"?>
<!-- 
 * Copyright (C) 2016 Dienst voor het kadaster en de openbare registers
 * 
 * This file is part of Imvertor.
 *
 * Imvertor is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Imvertor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Imvertor.  If not, see <http://www.gnu.org/licenses/>.
-->
<xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:UML="omg.org/UML1.3"
    
    xmlns:imvert="http://www.imvertor.org/schema/system"
    xmlns:ext="http://www.imvertor.org/xsl/extensions"
    xmlns:imf="http://www.imvertor.org/xsl/functions"
   
    xmlns:ekf="http://EliotKimber/functions"

    xmlns:StUF="http://www.egem.nl/StUF/StUF0301" 
    xmlns:bg="http://www.egem.nl/StUF/sector/bg/0310" 
    xmlns:metadata="http://www.kinggemeenten.nl/metadataVoorVerwerking" 
    xmlns:ztc="http://www.kinggemeenten.nl/ztc0310" 
    xmlns:stuf="http://www.egem.nl/StUF/StUF0301" 

    exclude-result-prefixes="xsl UML imvert imvert ekf"
    version="2.0">
    
    <xsl:import href="../common/Imvert-common.xsl"/>

    <xsl:param name="prefix" select="'ztc'"/>
    
    <xsl:output indent="yes" method="xml" encoding="UTF-8"/>
    
    <xsl:variable name="xsd-folder-path" select="imf:get-config-string('system','xsd-folder-path')"/>
    <xsl:variable name="allow-comments-in-schema" select="true() or $debug = 'true'"/>
    
    <xsl:variable name="predefined-scalar-types" select="('scalar-datetime','scalar-date','scalar-year','scalar-yearmonth')"/>
    
    <xsl:template match="/">
        <root/><!-- dummy output -->
        <xsl:apply-templates select="imvert:packages"/>
    </xsl:template>
    
    <xsl:template match="imvert:packages">
        <xsl:variable name="schemafile" select="concat($xsd-folder-path,'RESULT.XSD')"/>
        <xsl:variable name="schema" as="element()">
            <xs:schema 
                attributeFormDefault="unqualified" 
                elementFormDefault="qualified" 
                targetNamespace="http://www.kinggemeenten.nl/ztc0310" 
                version="010000" 
                xmlns="http://www.w3.org/2001/XMLSchema">

                <!--<xs:import schemaLocation="file:/d:/projects/validprojects/KING/input/ztc0310/bg0310_simpleTypes.xsd" namespace="http://www.egem.nl/StUF/sector/bg/0310" />-->
                <xs:import schemaLocation="StUF0301.xsd" namespace="http://www.egem.nl/StUF/StUF0301" />

                <xs:annotation>
                    <xs:appinfo><xsl:value-of select="concat('Generated by ', $imvertor-version,' at ',current-dateTime())"/></xs:appinfo>
                </xs:annotation>
              
                <xs:annotation>
                    <xs:documentation>(Gegevensgroeptypen) Basis entiteiten schema voor ztc0310.</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-composite')]" mode="mode-gegevensgroeptype"/>
                
                <?x
                <xs:annotation>
                    <xs:documentation>(Referentielijsten)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-referentielijst')]" mode="mode-referentielijst"/>
                 ?>           
                
                <xs:annotation>
                    <xs:documentation>(Basistypen)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-objecttype')]" mode="mode-objecttype"/>
                
                <xs:annotation>
                    <xs:documentation>(Kerngegevens)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-objecttype')]" mode="mode-kerngegevens"/>
                
                <xs:annotation>
                    <xs:documentation>(Attribuuttypen) Schema met de binnen ztc0310 gebruikte StUF-ZTC simpleTypes.</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-declare-attribute-type"/>
                </xsl:for-each-group>
                
                <?x
                <xs:annotation>
                    <xs:documentation>(Associatietypen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:association" 
                    group-by="imf:get-namestruct(.)[3]">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-declare-association-type"/>
                </xsl:for-each-group>
                ?>
                
                <!--
                    Als geen type-ID beschikbaar is, is het een "bare type" (zoals AN80). 
                -->
                <xs:annotation>
                    <xs:documentation>(Simpletypes)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[empty(imvert:type-id)]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-declare-attribute-simpletype"/>
                </xsl:for-each-group>
                
                
            </xs:schema>
        </xsl:variable>
        <xsl:result-document href="{$schemafile}" method="xml" indent="yes" encoding="UTF-8" exclude-result-prefixes="#all">
            <xsl:apply-templates select="$schema" mode="xsd-cleanup"/>
        </xsl:result-document>
    </xsl:template>
    
    <!-- Groepsattribuutsoort -->
    <xsl:template match="imvert:class" mode="mode-gegevensgroeptype">
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:comment select="concat('Groepsattribuutsoort ',@display-name)"/>
        
        <xs:complexType name="{$compiled-name}">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="imf:get-documentation(.)"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xsl:comment select="'(Attributes)'"/>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>
                <!-- TODO ook bij gegevensgroeptypen?? --> 
                <xsl:comment select="'(Groepen)'"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[imvert:aggregation = 'composite']" mode="mode-local-composition"/>
                <xsl:comment select="'(Associations)'"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[not(imvert:aggregation = 'composite')]" mode="mode-local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
                
                <!-- TODO geldt onderstaande niet meer? -->
                <?x 
                <xsl:variable name="inkomende-associaties" select="$document//imvert:association[imf:get-type-id(.) = $id]"/>
                <xsl:apply-templates select="$inkomende-associaties" mode="mode-local-association">
                    <xsl:with-param name="richting">inkomend</xsl:with-param>
                </xsl:apply-templates>
                ?>
                
            </xs:sequence>
        </xs:complexType>
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-objecttype">
        <xsl:variable name="hisform-on-attributes" select=".//imvert:attribute[imf:get-history(.)[1]]"/>
        <xsl:variable name="hismate-on-attributes" select=".//imvert:attribute[imf:get-history(.)[2]]"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
       
        <xsl:comment select="concat('Objecttype ',imvert:name/@original)"/>
        
        <xs:complexType name="{imvert:alias}-basis">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="concat(imvert:name/@original,': ', imf:get-documentation(.))"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xsl:comment select="'(Attributes)'"/>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>

                <xsl:comment select="'(Compositie relaties)'"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[imvert:aggregation = 'composite']" mode="mode-local-composition"/>
                
                <xsl:comment select="'(History)'"/>
                <xs:element ref="StUF:tijdvakGeldigheid" minOccurs="0"/><!-- TODO wanneer opnemen? -->
                <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                <xs:element ref="aanvullendeElementen" minOccurs="0"/>
                <xsl:if test="$hismate-on-attributes">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', imvert:alias,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="$hisform-on-attributes">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', imvert:alias,'-basis')}"  
                        minOccurs="0" 
                        maxOccurs="unbounded"/>  
                </xsl:if>
               
                <xsl:comment select="'(Associations: uitgaand)'"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[not(imvert:aggregation = 'composite')]" mode="mode-local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
             
                <xsl:comment select="'(Associations: inkomend)'"/>
                <xsl:variable name="inkomende-associaties" select="$document//imvert:association[not(imvert:aggregation = 'composite') and imf:get-type-id(.) = $id]"/>
                <xsl:apply-templates select="$inkomende-associaties" mode="mode-local-association">
                    <xsl:with-param name="richting">inkomend</xsl:with-param>
                </xsl:apply-templates>
            </xs:sequence>
            <xs:attribute name="entiteittype" type="{concat($prefix,':Entiteittype',imvert:alias)}"/>
        </xs:complexType>
        
        <xs:simpleType name="{concat('Entiteittype',imvert:alias)}">
            <xs:restriction base="string">
                <xs:enumeration value="{imvert:alias}"/>
            </xs:restriction>
        </xs:simpleType>
    
    </xsl:template>
    
    <!-- Groepsattribuutsoort -->
    <xsl:template match="imvert:class" mode="mode-referentielijst">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:comment select="concat('Referentelijst ',@display-name)"/>
        
        <xs:complexType name="{$compiled-name}-tabel">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="imf:get-documentation(.)"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>
                <xs:element ref="StUF:tijdvakObject" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$compiled-name}"/>
            <xs:attribute ref="StUF:scope"/>
            <xs:attribute ref="StUF:verwerkingssoort"/>
        </xs:complexType>
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-kerngegevens">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="kerngegevens" select="imvert:*/imvert:*[imf:boolean(imvert:is-id)]"/> <!-- attributes and associations. -->
        
        <xsl:comment select="concat('Kerngegevens ',@display-name)"/>
        
        <xs:complexType name="{imvert:alias}-kerngegevens">
            <xs:complexContent>
                <xs:restriction base="{concat($prefix,':', imvert:alias,'-basis')}">
                    <xs:sequence>
                        <xsl:for-each select="$kerngegevens">
                            <xsl:choose>
                                <xsl:when test="self::imvert:attribute">
                                    <xsl:apply-templates select="." mode="mode-local-attribute"/>
                                </xsl:when>
                                <xsl:when test="self::imvert:association[imvert:aggregation = 'composite']">
                                    <xsl:apply-templates select="." mode="mode-local-composition">
                                        <xsl:with-param name="kerngegevens" select="true()"/>
                                    </xsl:apply-templates>
                                </xsl:when>
                                <xsl:when test="self::imvert:association[not(imvert:aggregation = 'composite')]">
                                    <xsl:apply-templates select="." mode="mode-local-association">
                                        <xsl:with-param name="kerngegevens" select="true()"/>
                                        <xsl:with-param name="richting" select="'uitgaand'"/>
                                    </xsl:apply-templates>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:sequence select="."/>
                                </xsl:otherwise>
                            </xsl:choose>
                        </xsl:for-each>
                    </xs:sequence>
                    <xs:attribute name="StUF:entiteittype" use="required" type="{concat($prefix, ':Entiteittype', imvert:alias)}"/>
                    <xs:attribute ref="StUF:sleutelVerzendend"/>
                    <xs:attribute ref="StUF:sleutelOntvangend"/>
                    <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                    <xs:attribute ref="StUF:noValue" use="prohibited"/>
                    <xs:attribute ref="StUF:scope" use="prohibited"/>
                    <xs:attribute ref="StUF:verwerkingssoort"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
    </xsl:template>
    
    <!-- Attribuutsoort -->
    <xsl:template match="imvert:attribute" mode="mode-local-attribute">
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        
        <xsl:comment select="concat('Local attribute ',@display-name)"/>

        <xsl:choose>
            <xsl:when test="imvert:type-name = $predefined-scalar-types">
                <xsl:variable name="typeref">
                    <xsl:choose>
                        <xsl:when test="imvert:type-name = 'scalar-date'">
                            <xsl:value-of select="'StUF:MogelijkOnvolledigeDatum-e'"/>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-datetime'">
                            <xsl:value-of select="'StUF:MogelijkOnvolledigeDatumTijd-e'"/>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-year'">
                            <xsl:value-of select="'StUF:Jaar-e'"/>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-jearmonth'">
                            <xsl:value-of select="'StUF:JaarMaand-e'"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:variable>
                
                <xs:element
                    name="{$compiled-name}" 
                    type="{$typeref}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    metadata:formeleHistorie="{$history[1]}"
                    metadata:materieleHistorie="{$history[2]}"     
                />
            </xsl:when>
            <xsl:otherwise>
                
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name), '-e')}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    metadata:formeleHistorie="{$history[1]}"
                    metadata:materieleHistorie="{$history[2]}"     
                />
                
            </xsl:otherwise>
        </xsl:choose>
     
    </xsl:template>
    
    <!-- dit betreft echte relaties, dus geen composities -->
    <xsl:template match="imvert:association" mode="mode-local-association">
        <xsl:param name="kerngegevens" select="false()"/>
        <xsl:param name="richting" select="'uitgaand'"/>
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert:class"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        
        <xsl:choose>
            <xsl:when test="$richting = 'uitgaand'">
                <xsl:comment select="concat('Uitgaande relatie ',@display-name)"/>
                
                <xsl:variable name="heen-typeref" select="concat($prefix, ':', imvert:alias,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="target-cardinality" select="if ($history[2]) then 'unbounded' else $cardinality[4]"/> <!-- als materiele historie, dan is target altijd unbounded -->
                <xs:element
                    name="{imvert:name}" 
                    type="{$heen-typeref}" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    metadata:formeleHistorie="{$history[1]}"
                    metadata:materieleHistorie="{$history[2]}"     
                />
            </xsl:when>
            <xsl:when test="imf:boolean(imf:get-taggedvalue(.,'Relatiesoort terugrelatie'))">
                <xsl:comment select="concat('Inkomende relatie ',@display-name)"/>
                
                <xsl:variable name="associatie-naam" select="imf:get-taggedvalue(.,'Mnemonic relatiesoort terugrelatie')"/>
                <xsl:variable name="terug-typeref" select="concat($prefix, ':',$associatie-naam ,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="target-cardinality" select="if ($history[2]) then 'unbounded' else $cardinality[2]"/> <!-- als materiele historie, dan is target altijd unbounded -->
                <xs:element
                    name="{concat($source/imvert:alias,imf:get-relation-suffix($source)[1])}" 
                    type="{$terug-typeref}" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    metadata:formeleHistorie="{$history[1]}"
                    metadata:materieleHistorie="{$history[2]}"     
                />
            </xsl:when>
            <xsl:otherwise>
               <!-- er hoeft geen terugrelatie te worden gegenereerd -->
            </xsl:otherwise>
        </xsl:choose>
    
    </xsl:template>
    
    <!-- dit betreft gegevensgroepen, dus composities -->
    <xsl:template match="imvert:association" mode="mode-local-composition">
        <xsl:param name="kerngegevens" select="false()"/>

        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <!-- TODO wat betekent: de cardinaliteit van een groep? -->
        <xs:element
            name="{imvert:name}" 
            type="{concat($prefix, ':', $compiled-name)}" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
            metadata:formeleHistorie="{$history[1]}"
            metadata:materieleHistorie="{$history[2]}"     
        />
        
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-declare-attribute-type">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-stereotype" select="imf:get-stereotype($type)"/>
        
        <xsl:comment select="concat('Attribute declaration ',@display-name)"/>
        
        <xsl:if test="not(imvert:type-name = $predefined-scalar-types)">
            <xsl:comment select="concat('Attribuut type (complex) ',@display-name)"/>
            <xs:complexType name="{imf:capitalize($compiled-name)}-e">
                <xs:choice>
                    <xs:element name="w" type="{$prefix}:{imf:capitalize($compiled-name)}"/>
                    <xs:element name="l" type="'StUF:NoValue'"/>
                </xs:choice>
            </xs:complexType>
            <xs:complexType name="{imf:capitalize($compiled-name)}-s">
                <xs:choice>
                    <xs:element name="w" type="{$prefix}:{imf:capitalize($compiled-name)}-w"/>
                </xs:choice>
            </xs:complexType>
            <xs:complexType name="{imf:capitalize($compiled-name)}-w">
                <xs:simpleContent>
                    <xs:extension base="{$prefix}:{imf:capitalize($compiled-name)}">
                        <xs:attribute ref="StUF:wildcard"/>    
                    </xs:extension>
                </xs:simpleContent>
            </xs:complexType>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="imvert:association" mode="mode-declare-association-type">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert:class"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        
        <xsl:variable name="hisform-on-association" select="imf:get-history(.)[1]"/>
        <xsl:variable name="hismate-on-association" select="imf:get-history(.)[2]"/>
        
        <xsl:variable name="association-class" select="imf:get-by-id(imvert:association-class/imvert:type-id)"/>
        <xsl:variable name="association-class-attributes" select="$association-class//imvert:attribute"/>
        
        <xsl:variable name="suffix" select="imf:get-relation-suffix(.)"/>
        
        <xsl:variable name="source-alias" select="imvert:source-alias"/>
        <xsl:variable name="target-alias" select="imvert:target-alias"/>
        
        <xsl:comment select="concat('Outgoing Association declaration ',@display-name)"/>
    
        <xsl:variable name="associatie-naam" select="imvert:alias"/>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xs:annotation>
                <xs:documentation>
                    <?c3 volledige naam van de relatie in doc ?>
                    <xsl:value-of select="concat(imvert:name/@original,': ', imf:get-documentation(.))"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xs:element 
                    name="gerelateerde" 
                    type="{$prefix}:{$target/imvert:alias}-basis"
                    minOccurs="0"/>
                
                <!-- add the attributes of the association class, if any -->
                <xsl:apply-templates select="$association-class-attributes" mode="mode-local-attribute"/>
                
                <xs:element ref="StUF:tijdvakRelatie" minOccurs="0"/>
                <xs:element ref="StUF:tijdstipRegistratie" minOccurs="0"/>
                <xs:element ref="StUF:extraElementen" minOccurs="0"/>
                <xsl:if test="exists($association-class) and $hismate-on-association">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="exists($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
                <xsl:if test="empty($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeelRelatie" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" fixed="{$associatie-naam}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
        
        <xsl:comment select="concat('Outgoing Association kerngegevens ',@display-name)"/>
        
        <xs:complexType name="{$associatie-naam}-kerngegevens">
            <xs:annotation>
                <xs:documentation>Kerngegevens van de relatie</xs:documentation>
            </xs:annotation>
            <xs:complexContent>
                <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                    <xs:sequence>
                        <xs:element 
                            name="gerelateerde" 
                            type="{$prefix}:{$target/imvert:alias}-kerngegevens"
                            minOccurs="0"/>
                    </xs:sequence>
                    <!-- add the attributes of the association class, if any -->
                    <xsl:apply-templates select="$association-class-attributes" mode="mode-local-attribute"/>
                    
                    <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$associatie-naam}"/>
                    <xs:attribute ref="StUF:sleutelVerzendend"/>
                    <xs:attribute ref="StUF:sleutelOntvangend"/>
                    <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                    <xs:attribute ref="StUF:noValue" use="prohibited"/>
                    <xs:attribute ref="StUF:scope" use="prohibited"/>
                    <xs:attribute ref="StUF:verwerkingssoort"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
        
        <xsl:comment select="concat('Incoming Association declaration ',@display-name)"/>
        
        <xsl:variable name="associatie-naam" select="imf:get-taggedvalue(.,'Mnemonic relatiesoort terugrelatie')"/>
        <xsl:if test="not(normalize-space($associatie-naam))">
            <xsl:value-of select="imf:msg(.,'ERROR','No Menomonic specified for terugrelatie',())"/>
        </xsl:if>
        
        
        <xsl:variable name="original-incoming" select="imf:get-taggedvalue(.,'Naam terugrelatie')"/>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="concat($original-incoming,': ', imf:get-documentation(.))"/>
                </xs:documentation>
            </xs:annotation>
            <xs:sequence>
                <xs:element 
                    name="gerelateerde" 
                    type="{$prefix}:{$source/imvert:alias}-basis"
                    minOccurs="0"/>
                
                <!-- add the attributes of the association class, if any -->
                <xsl:apply-templates select="$association-class-attributes" mode="mode-local-attribute"/>
                
                <xs:element ref="StUF:tijdvakRelatie" minOccurs="0"/>
                
                <xs:element 
                    ref="StUF:extraElementen" 
                    minOccurs="0"/>
                <xsl:if test="exists($association-class) and $hismate-on-association">
                    <xs:element name ="historieMaterieel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                        minOccurs="0"     
                        maxOccurs="unbounded"/>
                </xsl:if>
                <xsl:if test="exists($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeel" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
                <xsl:if test="empty($association-class) and $hisform-on-association">
                    <xs:element name="historieFormeelRelatie" 
                        type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                        minOccurs="0"/>  
                </xsl:if>
            </xs:sequence>
            <xs:attribute ref="StUF:entiteittype" fixed="{$associatie-naam}"/>
            <xs:attributeGroup ref="StUF:entiteit"/>
        </xs:complexType>
    
        <xsl:comment select="concat('Incoming Association kerngegevens ',@display-name)"/>
        
        <xs:complexType name="{$associatie-naam}-kerngegevens">
            <xs:annotation>
                <xs:documentation>Kerngegevens van de relatie</xs:documentation>
            </xs:annotation>
            <xs:complexContent>
                <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                    <xs:sequence>
                        <xs:element 
                            name="gerelateerde" 
                            type="{$prefix}:{$source/imvert:alias}-kerngegevens"
                            minOccurs="0"/>
                    </xs:sequence>
                    <xs:attribute ref="StUF:entiteittype" use="required" fixed="{$associatie-naam}"/>
                    <xs:attribute ref="StUF:sleutelVerzendend"/>
                    <xs:attribute ref="StUF:sleutelOntvangend"/>
                    <xs:attribute ref="StUF:sleutelGegevensbeheer"/>
                    <xs:attribute ref="StUF:noValue" use="prohibited"/>
                    <xs:attribute ref="StUF:scope" use="prohibited"/>
                    <xs:attribute ref="StUF:verwerkingssoort"/>
                </xs:restriction>
            </xs:complexContent>
        </xs:complexType>
  
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-declare-attribute-simpletype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="maxlength" select="imvert:max-length"/>
        <xsl:variable name="totaldigits" select="imvert:total-digits"/>
        <xsl:variable name="fractiondigits" select="imvert:fraction-digits"/>
        
        <xsl:if test="not(imvert:type-name = ('scalar-indic','scalar-uri')) and not(imvert:baretype = ('OnvolledigeDatum'))">
            <xsl:comment select="concat('Attribuut type (simple) ',@display-name)"/>
            <xsl:variable name="min-waarde" select="imf:get-taggedvalue(.,'Minimum waarde (inclusief)')"/>
            <xsl:variable name="max-waarde" select="imf:get-taggedvalue(.,'Maximum waarde (inclusief)')"/>
            <xsl:variable name="min-length" select="imf:get-taggedvalue(.,'Minimum lengte')"/>
            <xsl:variable name="facetten">
                <xsl:if test="imvert:pattern">
                    <xs:pattern value="{.}"/>
                </xsl:if>
                <xsl:if test="$min-waarde">
                    <xs:minInclusive value="{$min-waarde}"/>
                </xsl:if>
                <xsl:if test="$max-waarde">
                    <xs:maxInclusive value="{$max-waarde}"/>
                </xsl:if>
                <xsl:if test="$min-length">
                    <xs:minLength value="{$min-length}"/>
                </xsl:if>
            </xsl:variable>
            <xs:simpleType name="{imf:capitalize($compiled-name)}">
                <xsl:choose>
                    <xsl:when test="imvert:type-name = ''">
                        <!-- een enumeratie, wordt niet gedeclareerd -->
                    </xsl:when>
                    <xsl:when test="imvert:type-name = 'scalar-string' and exists($maxlength)">
                        <xs:restriction base="xs:string">
                            <xs:maxLength value="{$maxlength}" />
                            <xsl:sequence select="$facetten"/>
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="imvert:type-name = 'scalar-string'">
                        <xs:restriction base="xs:string">
                            <xsl:sequence select="$facetten"/>
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="imvert:type-name = 'scalar-integer' and $totaldigits and $fractiondigits">
                        <xs:restriction base="xs:integer">
                            <xs:totalDigits value="{$totaldigits}" />
                            <xs:factionDigits value="{$fractiondigits}" />
                            <xsl:sequence select="$facetten"/>
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="imvert:type-name = 'scalar-boolean'">
                        <xs:restriction base="xs:boolean">
                            <xsl:sequence select="$facetten"/>
                        </xs:restriction>
                    </xsl:when>
                    <xsl:when test="imvert:type-name = 'scalar-txt'">
                        <xs:restriction base="xs:string">
                            <xsl:sequence select="$facetten"/>
                        </xs:restriction>
                    </xsl:when>    
                    <xsl:when test="imvert:type-name = 'scalar-uri'">
                        <xs:restriction base="xs:anyURI">
                            <xsl:sequence select="$facetten"/>
                        </xs:restriction>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:value-of select="imf:msg(.,'ERROR','Cannot handle the simple attribute type: [1]', imvert:type-name)"/>
                    </xsl:otherwise>                
                </xsl:choose>
            </xs:simpleType>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-declare-attribute-enumeratie">
        <xsl:comment select="concat('TODO: ENUMERATIE: ', imvert:name/@original)"/>
    </xsl:template>
      
    <xsl:function name="imf:get-compiled-name">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="type" select="local-name($this)"/>
        <xsl:variable name="stereotype" select="imf:get-stereotype($this)"/>
        <xsl:variable name="alias" select="$this/imvert:alias"/>
        <xsl:variable name="name-raw" select="$this/imvert:name"/>
        <xsl:variable name="name" select="replace($name-raw,'[/:\s]+','_')"/>
        <xsl:choose>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-composite')">
                <xsl:value-of select="concat(imf:capitalize($name),'Grp')"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-objecttype')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-relatieklasse')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-referentielijst')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-complextype')">
                <xsl:sequence select="imf:msg($this,'DEBUG','TODO COMPLEX TYPE',())"/>
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-enumeration')">
                <xsl:sequence select="imf:msg($this,'DEBUG','TODO ENUMERATION',())"/>
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-attribute')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-referentieelement')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $stereotype = 'relatiesoort' and normalize-space($alias)">
                <!-- if this relation occurs multiple times, add the alias of the target object -->
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $stereotype = 'relatiesoort'">
                <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                <xsl:value-of select="lower-case($name)"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and normalize-space($alias)"> <!-- composite -->
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'association'">
                <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                <xsl:value-of select="lower-case($name)"/>
            </xsl:when>
            <!-- TODO meer soorten namen uitwerken? -->
            <xsl:otherwise>
                <xsl:sequence select="imf:msg($this,'ERROR','Unknown type [1] with stereo [2]', ($type, string-join($stereotype,', ')))"/>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="imf:get-cardinality" as="xs:string+">
        <xsl:param name="this"/>
        <xsl:variable name="source-min" select="$this/imvert:min-occurs-source"/>
        <xsl:variable name="source-max" select="$this/imvert:max-occurs-source"/>
        <xsl:variable name="target-min" select="$this/imvert:min-occurs"/>
        <xsl:variable name="target-max" select="$this/imvert:max-occurs"/>
        <xsl:sequence select="(normalize-space($source-min),normalize-space($source-max),normalize-space($target-min),normalize-space($target-max))"/>
    </xsl:function>
    
    <!-- return (formal?, material?) boolean values -->
    <xsl:function name="imf:get-history" as="xs:boolean+">
        <xsl:param name="this"/>
        <xsl:variable name="formal-this" select="imf:get-taggedvalue($this,'Indicatie formele historie')"/>
        <xsl:variable name="formal-grp" select="imf:get-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie formele historie')"/>
        <xsl:variable name="formal" select="if ($formal-this = 'zie groep') then $formal-grp else $formal-this"/>
        <xsl:variable name="material-this" select="imf:get-taggedvalue($this,'Indicatie materiële historie')"/>
        <xsl:variable name="material-grp" select="imf:get-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie materiële historie')"/>
        <xsl:variable name="material" select="if ($material-this = 'zie groep') then $material-grp else $material-this"/>
        <xsl:sequence select="(imf:boolean($this,$formal),imf:boolean($this,$material))"/>
    </xsl:function>

    <xsl:function name="imf:get-stereotype" as="xs:string*">
        <xsl:param name="this"/>
        <xsl:sequence select="$this/imvert:stereotype"/>
    </xsl:function>

    <xsl:function name="imf:get-taggedvalue" as="xs:string?">
        <xsl:param name="this"/>
        <xsl:param name="name"/>
        <xsl:value-of select="$this/imvert:tagged-values/imvert:tagged-value[imvert:name = $name]/imvert:value"/>
    </xsl:function>
    
    <xsl:function name="imf:get-groepattribuutsoort" as="element()?">
        <xsl:param name="this" as="element()"/>
        <xsl:sequence select="$this/ancestor-or-self::imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-composite')]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-documentation">
        <xsl:param name="this"/>
        <xsl:value-of select="normalize-space($this/imvert:documentation)"/>
    </xsl:function>
    
    <!-- tools -->
    
    <xsl:function name="imf:capitalize">
        <xsl:param name="name"/>
        <xsl:value-of select="concat(upper-case(substring($name,1,1)),substring($name,2))"/>
    </xsl:function>
    
    <xsl:function name="imf:boolean" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:param name="value"/>
        <xsl:sequence select="$value eq 'Ja'"/>
    </xsl:function>

    <!-- 
        ============================================== 
        common for all model based stylesheets 
        ============================================== 
    -->
    
    <xsl:function name="imf:get-construct-name" as="item()*">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="name" select="imf:sub-name($this)"/>
        <xsl:variable name="package-name" select="imf:sub-name($this/ancestor-or-self::imvert:package[1])"/>
        <xsl:variable name="class-name" select="imf:sub-name($this/ancestor-or-self::imvert:class[1])"/>
        <xsl:choose>
            <xsl:when test="$this/self::imvert:package">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:base">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:class">
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:type">
                <xsl:sequence select="imf:compile-construct-name($this/imvert:type-package,$this/imvert:type-name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:attribute">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'attrib')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:association[not(imf:sub-name(.))]">
                <xsl:variable name="type" select="concat('[',$this/imvert:type-name,']')"/>
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$type,'aggr')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:association">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'assoc')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,local-name($this),'')"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="imf:sub-name">
        <xsl:param name="this"/>
        <xsl:value-of select="$this/imvert:name"/>
    </xsl:function>

    <xsl:function name="imf:get-class" as="element()?">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:type-id"/>
        <xsl:if test="normalize-space($id)">
            <xsl:variable name="class" select="root($this)//imvert:class[imf:get-id(.) = $id]"/>
            <xsl:sequence select="$class"/>
        </xsl:if>
    </xsl:function>

    <xsl:function name="imf:stub-create-name">
        <xsl:param name="literal-name"/>
        <xsl:value-of select="concat('STUB-',replace($literal-name,'[^a-zA-Z]','_'))"/>
    </xsl:function>

    <xsl:function name="imf:parse-names" as="xs:string*">
        <xsl:param name="text" as="xs:string"/>
        <xsl:analyze-string select="$text" regex="'(.+?)'">
            <xsl:matching-substring>
                <xsl:value-of select="regex-group(1)"/>
            </xsl:matching-substring>
        </xsl:analyze-string>
    </xsl:function>
    
    <xsl:function name="imf:get-by-id" as="element()?">
        <xsl:param name="id"/>
        <xsl:sequence select="$document//*[imf:get-id(.) = $id]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- get the ID of the type of the attribute or association -->
    <xsl:function name="imf:get-type-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:type-id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- return suffixes to append to relation names. [1] is incoming, [2] is outgoing -->
    <xsl:function name="imf:get-relation-suffix" as="xs:string+">
        <xsl:param name="this"/> <!-- an Association element -->
        <xsl:variable name="targetAlias" select="$this/imvert:target-alias"/>
        <xsl:variable name="targetId" select="imf:get-type-id($this)"/>
        
        <xsl:variable name="other-associations" select="root($this)//imvert:association[imvert:target-alias = $targetAlias and imf:get-type-id(.) = $targetId]"/>
        <xsl:variable name="class" select="$this/ancestor::imvert:class"/>
        <xsl:value-of select="if (count($other-associations) gt 1) then imf:capitalize($class/imvert:name) else ''"/>

        <xsl:variable name="class" select="root($this)//imvert:class[imf:get-id(.) = $targetId]"/>
        <xsl:value-of select="if (count($this/../imvert:association[imvert:target-alias = $targetAlias]) gt 1) then imf:capitalize($class/imvert:name) else ''"/>

    </xsl:function>
    
    <!-- =================== cleanup =================== -->
   
    <xsl:template match="xs:schema" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:variable name="names" select="for $n in (xs:*/@name) return string($n)" as="xs:string*"/>
            <xsl:variable name="names-dup" select="distinct-values($names[count(index-of($names,.)) gt 1])"/>
            <xsl:apply-templates mode="xsd-cleanup">
                <xsl:with-param name="names-dup" select="$names-dup"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="xs:complexType | xs:simpleType" mode="xsd-cleanup">
        <xsl:param name="names-dup"/>
        <xsl:variable name="name" select="@name"/>
        <xsl:choose>
            <xsl:when test="($name = $names-dup) and (preceding-sibling::xs:*/@name = $name)">
                <!--<xsl:comment>DUPLICATE REMOVED</xsl:comment>-->
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    
    <xsl:template match="*" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="xsd-cleanup"/>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="comment()" mode="xsd-cleanup">
        <xsl:if test="$allow-comments-in-schema">
            <xsl:sequence select="."/>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="imvert:dummy"/>
</xsl:stylesheet>
