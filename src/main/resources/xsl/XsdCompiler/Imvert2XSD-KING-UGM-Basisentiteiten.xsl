<?xml version="1.0" encoding="UTF-8"?>
<!-- 
 * Copyright (C) 2016 Dienst voor het kadaster en de openbare registers
 * 
 * This file is part of Imvertor.
 *
 * Imvertor is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Imvertor is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Imvertor.  If not, see <http://www.gnu.org/licenses/>.
-->
<xsl:stylesheet 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:UML="omg.org/UML1.3"
    
    xmlns:imvert="http://www.imvertor.org/schema/system"
    xmlns:ext="http://www.imvertor.org/xsl/extensions"
    xmlns:imf="http://www.imvertor.org/xsl/functions"
   
    xmlns:ekf="http://EliotKimber/functions"

    xmlns:StUF="http://www.stufstandaarden.nl/StUF/StUF0302" 
    xmlns:metadata="http://www.kinggemeenten.nl/metadataVoorVerwerking" 
   
    xmlns:bg="http://www.egem.nl/StUF/sector/bg/0310" 
    xmlns:ztc="http://www.kinggemeenten.nl/ztc0310" 
    xmlns:gml="http://www.opengis.net/gml/3.2"
    
    exclude-result-prefixes="xsl UML imvert imvert ekf"
    version="2.0">
    
    <!-- TODO als in onderzoek (tv), dan het element <xs:element name="inOnderzoek" type="xs:boolean"/> 
        
        Ja, uitlezen uit het SIM.
        henri levert de specs.
        zie #487922
        -->
    
    <xsl:import href="../common/Imvert-common.xsl"/>
    <xsl:import href="../common/Imvert-common-derivation.xsl"/>
    
    <xsl:param name="prefix" select="'bg'"/>
    <xsl:param name="target-namespace" select="'http://www.egem.nl/StUF/sector/bg/0310'"/>
    <xsl:param name="StUF-prefix" select="'StUF'"/>
    
    <xsl:output indent="yes" method="xml" encoding="UTF-8"/>
    
    <xsl:variable name="stylesheet-code">BES</xsl:variable>
    <xsl:variable name="debugging" select="imf:debug-mode($stylesheet-code)"/>

    <xsl:variable name="xsd-folder-path" select="imf:get-config-string('system','xsd-folder-path')"/>
    <xsl:variable name="allow-comments-in-schema" select="true() or $debug = 'true'"/>
    
    <xsl:variable 
        name="external-schema-names" 
        select="$imvert-document//imvert:package[imvert:stereotype=(imf:get-config-stereotypes(('stereotype-name-external-package','stereotype-name-system-package')))]/imvert:name" 
        as="xs:string*"/>
    
    <xsl:variable name="elementFormDefault" select="if (imf:boolean(imf:get-config-string('cli','elementisqualified','yes'))) then 'qualified' else 'unqualified'"/>
    <xsl:variable name="attributeFormDefault" select="if (imf:boolean(imf:get-config-string('cli','attributeisqualified','no'))) then 'qualified' else 'unqualified'"/>
   
    <xsl:template match="/">
        <root/><!-- dummy output -->
        <xsl:apply-templates select="imvert:packages"/>
    </xsl:template>
    
    <xsl:template match="imvert:packages">
        <xsl:variable name="schemafile" select="concat($xsd-folder-path,'RESULT.XSD')"/>
        <xsl:variable name="schema" as="element()">
            <xs:schema 
                attributeFormDefault="{$attributeFormDefault}" 
                elementFormDefault="{$elementFormDefault}" 
                targetNamespace="{$target-namespace}" 
                version="010000" 
                xmlns="http://www.w3.org/2001/XMLSchema">

                <!--<xs:import schemaLocation="file:/d:/projects/validprojects/KING/input/ztc0310/bg0310_simpleTypes.xsd" namespace="http://www.egem.nl/StUF/sector/bg/0310" />-->
                <xs:import schemaLocation="../StUF/StUF0302.xsd" namespace="http://www.stufstandaarden.nl/StUF/StUF0302" />
                <xs:import schemaLocation="../gml/3.2.1/gml.xsd" namespace="http://www.opengis.net/gml/3.2" />
                
                <xs:annotation>
                    <xs:appinfo><xsl:value-of select="concat('Generated by ', $imvertor-version,' at ',imf:format-dateTime(current-dateTime()))"/></xs:appinfo>
                </xs:annotation>
                
                <xs:attribute name="entiteittype" type="{$StUF-prefix}:Entiteittype"/>  
                
                <xs:simpleType name="NoValue">
                    <xs:restriction base="string">
                        <xs:enumeration value="nietOndersteund"/>
                        <xs:enumeration value="nietGeautoriseerd"/>
                        <xs:enumeration value="geenWaarde"/>
                        <xs:enumeration value="waardeBestaat"/>
                        <xs:enumeration value="waardeOnbekend"/>
                        <xs:enumeration value="vastgesteldOnbekend"/>
                    </xs:restriction>
                </xs:simpleType>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Basistypen)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-objecttype')]" mode="mode-global-objecttype"/>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Associatietypen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:association[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-relatiesoort')]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-association-type"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Kerngegevens)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-objecttype')]" mode="mode-global-kerngegevens"/>
                
                <xs:annotation>
                    <xs:documentation>(Gegevensgroeptypen)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-composite')]" mode="mode-global-gegevensgroeptype"/>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Attribuuttypen) </xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[imf:get-stereotype(.) = imf:get-config-stereotypes(('stereotype-name-attribute','stereotype-name-data-element'))]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-type"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Complex types)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-complextype')]" mode="mode-global-complextype"/>
       
                <!--
                    Als geen type-ID beschikbaar is, is het een "bare type" (zoals AN80). 
                -->
                <xs:annotation>
                    <xs:documentation>(Declaratie van Simpletype attributen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[empty(imvert:type-id)]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-simpletype"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van niet-Simple datatype attributen)</xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[exists(imvert:type-id)]" 
                    group-by="imf:get-compiled-name(.)">
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-niet-simpletype"/>
                </xsl:for-each-group>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Referentielijsten)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-referentielijst')]" mode="mode-global-objecttype"/>
                
                <!--XX
                <xs:annotation>
                    <xs:documentation>(Declaratie van referentie elementen) </xs:documentation>
                </xs:annotation> 
                <xsl:for-each-group 
                    select="//imvert:attribute[imf:get-stereotype(../..) = imf:get-config-stereotypes('stereotype-name-referentielijst')]" 
                    group-by="imf:get-compiled-name(.)">
                    <!- - let op: referentie elementen hebben stereotype "element" - ->
                    <xsl:apply-templates select="current-group()[1]" mode="mode-global-attribute-referentie-element"/>
                </xsl:for-each-group>
                XX-->
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Enumeraties)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-enumeration')]" mode="mode-global-enumeration"/>
                
                <xs:annotation>
                    <xs:documentation>(Declaratie van Unions)</xs:documentation>
                </xs:annotation>
                <xsl:apply-templates select="//imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-union')]" mode="mode-global-union"/>
            </xs:schema>
        </xsl:variable>
        
        <xsl:result-document href="{$schemafile}" method="xml" indent="yes" encoding="UTF-8" exclude-result-prefixes="#all">
            <xsl:apply-templates select="$schema" mode="xsd-cleanup"/>
        </xsl:result-document>
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-objecttype">
        <xsl:variable name="hisform-on-attributes" select=".//imvert:attribute[imf:get-history(.)[1]]"/>
        <xsl:variable name="hismate-on-attributes" select=".//imvert:attribute[imf:get-history(.)[2]]"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:variable name="superclasses" select="imf:get-superclass(.)"/>
        <xsl:variable name="subclasses" select="imf:get-subclasses(.)"/>
        
        <xsl:variable name="is-supertype" select="exists($subclasses)"/>
        <xsl:variable name="is-subtype" select="exists($superclasses)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype # ',imvert:name/@original))"/>
        
        <xsl:variable name="basis-body" as="element()*">
            <xs:sequence>
                <xsl:sequence select="imf:create-comment('mode-global-objecttype (Attributes)')"/>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>
                
                <xsl:sequence select="imf:create-comment('mode-global-objecttype (Compositie relaties)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[imvert:aggregation = 'composite']" mode="mode-local-composition">
                    <xsl:sort select="imvert:name"/>
                </xsl:apply-templates>
                
                <xsl:if test="not($is-supertype)">
                    <xsl:if test="imf:is-gebeurtenis(.)">
                        <xs:element name="gebeurtenis" type="{$StUF-prefix}:GebeurtenisMetAttributes-basis" minOccurs="0" maxOccurs="unbounded"/><!-- TODO onder welke condities? -->
                    </xsl:if>
                    <xsl:if test="imf:is-authentiek(.)">
                        <xs:element name="authentiek" type="{$StUF-prefix}:StatusMetagegeven-basis" minOccurs="0" maxOccurs="unbounded"/> <!--DONE bg:authentiek-TODO -->
                    </xsl:if>
                    <xsl:if test="imf:is-in-onderzoek(.)">
                        <xs:element name="inOnderzoek" type="{$StUF-prefix}:StatusMetagegeven-basis" minOccurs="0" maxOccurs="unbounded"/>
                    </xsl:if>
                    
                    <xs:element ref="{$StUF-prefix}:tijdvakGeldigheid" minOccurs="0"/>
                    <xs:element ref="{$StUF-prefix}:tijdstipRegistratie" minOccurs="0"/>
                    <xs:element ref="{$StUF-prefix}:extraElementen" minOccurs="0"/>
                    <xs:element ref="{$StUF-prefix}:aanvullendeElementen" minOccurs="0"/>
                    
                    <xsl:sequence select="imf:create-comment('(History)')"/>
                    <xsl:if test="$hismate-on-attributes">
                        <xs:element name ="historieMaterieel" 
                            type="{concat($prefix, ':', imvert:alias,'-basis')}" 
                            minOccurs="0"     
                            maxOccurs="unbounded"/>
                    </xsl:if>
                    <xsl:if test="$hisform-on-attributes">
                        <xs:element name="historieFormeel" 
                            type="{concat($prefix, ':', imvert:alias,'-basis')}"  
                            minOccurs="0" 
                            maxOccurs="1"/>  
                    </xsl:if>
                </xsl:if>
                            
                <xsl:sequence select="imf:create-comment('mode-global-objecttype (Associations: uitgaand)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[not(imvert:aggregation = 'composite')]" mode="mode-local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                    <xsl:sort select="imvert:name"/>
                </xsl:apply-templates>
            </xs:sequence>
            
            <xsl:choose>
                <xsl:when test="$is-supertype">
                    <xs:attributeGroup ref="{$StUF-prefix}:entiteit"/> 
                </xsl:when>
                <xsl:when test="$is-subtype">
                    <xs:attribute ref="{$prefix}:entiteittype" fixed="{imvert:alias}"/>
                </xsl:when>
                <xsl:otherwise>
                    <xs:attribute ref="{$prefix}:entiteittype" fixed="{imvert:alias}"/>
                    <xs:attributeGroup ref="{$StUF-prefix}:entiteit"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xsl:choose> <!-- TODO DONE ComplexType PES-basis moet een extension zijn van SUB-abstract -->
            <xsl:when test="$is-subtype and exists($superclasses[2])">  <!-- no example -->
                <xsl:sequence select="imf:msg(.,'ERROR','Unable to define subtype for multiple supertypes: [1]',string-join($superclasses[1]/imvert:name/@original,', '))"/>
            </xsl:when>
            
            <xsl:when test="$is-supertype">  <!-- e.g. SUB -->
                <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype is supertype but not subtype# ',imvert:name/@original))"/>
                <xs:complexType name="{imvert:alias}-super">
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xsl:sequence select="$basis-body"/>
                </xs:complexType>
            </xsl:when>
            
            <xsl:when test="$is-subtype"> <!-- e.g. NPS -->
                <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype is subtype # ',imvert:name/@original))"/>
                <xs:complexType name="{imvert:alias}-basis">
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',$superclasses[1]/imvert:alias,'-super')}">
                            <xsl:sequence select="$basis-body"/>     
                        </xs:extension>
                    </xs:complexContent>
                </xs:complexType>
               
            </xsl:when>
          
            <xsl:otherwise>  <!-- e.g. PND -->
                <xsl:sequence select="imf:create-comment(concat('mode-global-objecttype Objecttype is not a subtype or supertype # ',imvert:name/@original))"/>
                <xs:complexType name="{imvert:alias}-basis">
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xsl:sequence select="$basis-body"/>
                </xs:complexType>
            </xsl:otherwise>
        </xsl:choose>
           
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-kerngegevens">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <!-- <xsl:variable name="kerngegevens-x" select="imvert:*/imvert:*[imf:boolean(imvert:is-id)]"/> -->
        <xsl:variable name="kerngegevens" select="imvert:*/imvert:*[starts-with(imf:get-most-relevant-compiled-taggedvalue(.,'Indicatie kerngegeven'),'J')]"/><!-- attributes and associations. -->
        
        <xsl:variable name="superclasses" select="imf:get-superclasses(.)"/>
        <xsl:variable name="subclasses" select="imf:get-subclasses(.)"/>
        <xsl:variable name="is-subtype" select="exists($superclasses)"/>
        <xsl:variable name="is-supertype" select="exists($subclasses)"/>
        <xsl:variable name="is-abstract" select="imf:boolean(imvert:abstract)"/>
        
        <xsl:variable name="label" select="if ($is-supertype) then '-super' else '-basis'"/>
      
        <xsl:variable name="body-kern">
            <xs:sequence>
                <xsl:for-each select="$kerngegevens">
                    <xsl:choose>
                        <xsl:when test="self::imvert:attribute">
                            <xsl:apply-templates select="." mode="mode-local-attribute"/>
                        </xsl:when>
                        <xsl:when test="self::imvert:association[imvert:aggregation = 'composite']">
                            <xsl:apply-templates select="." mode="mode-local-composition">
                                <xsl:with-param name="kerngegevens" select="true()"/>
                            </xsl:apply-templates>
                        </xsl:when>
                        <xsl:when test="self::imvert:association[not(imvert:aggregation = 'composite')]">
                            <xsl:apply-templates select="." mode="mode-local-association">
                                <xsl:with-param name="kerngegevens" select="true()"/>
                                <xsl:with-param name="richting" select="'uitgaand'"/>
                            </xsl:apply-templates>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:sequence select="."/>
                        </xsl:otherwise>
                    </xsl:choose>
                </xsl:for-each>
            </xs:sequence>
        </xsl:variable>
        
        <xsl:if test="not($is-abstract)"><!-- TODO check deze conditie -->
            <xsl:sequence select="imf:create-comment(concat('mode-global-kerngegevens Kerngegevens # ',@display-name))"/>
            <xs:complexType name="{imvert:alias}-kerngegevens">
                <xs:complexContent>
                    <xs:restriction base="{$prefix}:{imvert:alias}-basis">
                        <xsl:sequence select="$body-kern"/>
                        <xs:attribute ref="{$prefix}:entiteittype" fixed="{imvert:alias}" use="required"/>
                        <xs:attribute ref="{$StUF-prefix}:noValue" use="prohibited"/>
                        <xs:attribute ref="{$StUF-prefix}:scope" use="prohibited"/>
                    </xs:restriction>
                </xs:complexContent>
            </xs:complexType>
        </xsl:if>
                
    </xsl:template>
    
    <!-- Groepsattribuutsoort -->
    <xsl:template match="imvert:class" mode="mode-global-gegevensgroeptype">
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-gegevensgroeptype Groepsattribuutsoort # ',@display-name))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}-basis">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:sequence minOccurs="0">
                <xsl:sequence select="imf:create-comment('mode-global-gegevensgroeptype (Attributes)')"/>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-attribute"/>
                <xsl:sequence select="imf:create-comment('mode-global-gegevensgroeptype (Groepen)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[imvert:aggregation = 'composite']" mode="mode-local-composition"/>
                <xsl:sequence select="imf:create-comment('mode-global-gegevensgroeptype (Associations)')"/>
                <xsl:apply-templates select="imvert:associations/imvert:association[not(imvert:aggregation = 'composite')]" mode="mode-local-association">
                    <xsl:with-param name="richting">uitgaand</xsl:with-param>
                </xsl:apply-templates>
            </xs:sequence>
        </xs:complexType>
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-complextype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-complextype Complextype # ',imvert:name/@original))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}"> 
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:sequence>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-data-element"/>
            </xs:sequence>
        </xs:complexType>
        <xsl:sequence select="imf:create-comment('And add voidable construct')"/><!-- DONE Complex datatype niet goed geïmplementeerd -->
        <xs:complexType name="{imf:capitalize($compiled-name)}-e">
            <xs:choice>
                <xs:element name="w" type="{$prefix}:{imf:capitalize($compiled-name)}"/>
                <xs:element name="l" type="{$StUF-prefix}:NoValue"/>
            </xs:choice>
        </xs:complexType>
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-referentielijst">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="id" select="imf:get-id(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-referentielijst Referentelijst # ',@display-name))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}-basis">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:sequence>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-referentielijst-element"/>
                <xs:element ref="{$StUF-prefix}:tijdvakObject" minOccurs="0"/>
                <xs:element ref="{$StUF-prefix}:tijdvakGeldigheid" minOccurs="0"/><!-- TODO wanneer opnemen? -->
                <xs:element ref="{$StUF-prefix}:tijdstipRegistratie" minOccurs="0"/>
                <xs:element ref="{$StUF-prefix}:extraElementen" minOccurs="0"/>
                <xs:element ref="{$StUF-prefix}:aanvullendeElementen" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="entiteittype" type="{concat($prefix, ':Entiteittype', $compiled-name)}"/>
            <xs:attribute ref="{$StUF-prefix}:scope"/>
            <xs:attribute ref="{$StUF-prefix}:verwerkingssoort"/> 
        </xs:complexType>
        
        <xs:simpleType name="{concat('Entiteittype',$compiled-name)}">
            <xs:restriction base="string">
                <xs:enumeration value="{imvert:alias}"/>
            </xs:restriction>
        </xs:simpleType>
        
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-enumeration">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-enumeration Enumeration # ',imvert:name/@original))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}-e"> 
            <xs:simpleContent>
                <xs:extension base="{$prefix}:{imf:capitalize($compiled-name)}">
                    <xs:attribute name="noValue" type="{$prefix}:NoValue"/>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
        
        <xs:simpleType name="{imf:capitalize($compiled-name)}">
            <xs:restriction base="xs:string">
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-enum"/>
            </xs:restriction>
        </xs:simpleType>
        
    </xsl:template>
    
    <xsl:template match="imvert:class" mode="mode-global-union">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-union Union # ',imvert:name/@original))"/>
        
        <xs:complexType name="{imf:capitalize($compiled-name)}">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:choice>
                <xsl:apply-templates select="imvert:attributes/imvert:attribute" mode="mode-local-union-element"/>
            </xs:choice>
        </xs:complexType>
        
    </xsl:template>
    
    
    <!-- LOCAL SUBSTRUCTURES -->
    
    <xsl:template match="imvert:attribute" mode="mode-local-attribute">
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="is-in-onderzoek" select="imf:is-in-onderzoek(.)"/>
        
        <xsl:variable name="type-is-referentietabel" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-referentielijst')"/>
        
        <!-- when referentietabel, assume the attribute is the is-id attriubute of the referentie tabel -->
        <xsl:variable name="applicable-attribute" select="if ($type-is-referentietabel) then $type//imvert:attribute[imf:boolean(imvert:is-id)] else ()"/>
       
        <xsl:for-each select="($applicable-attribute,.)[1]"> <!-- singleton -->
            
            <xsl:variable name="applicable-compiled-name" select="imf:get-compiled-name(.)"/>
            
            <xsl:variable name="type" select="imf:get-class(.)"/> <!-- possibly overrules the original att type  -->
      
            <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
            
            <xsl:variable name="type-is-datatype" select="$type/imvert:designation = 'datatype'"/>
            <xsl:variable name="type-is-complextype" select="$type-is-datatype and $type/imvert:stereotype = imf:get-config-stereotypes('stereotype-name-complextype')"/>
            <xsl:variable name="type-is-simpletype" select="$type-is-datatype"/>
            
            <xsl:variable name="type-is-scalar-base" select="imvert:type-name = ('scalar-integer','scalar-decimal','scalar-boolean')"/>
            <xsl:variable name="type-is-scalar-empty" select="imvert:type-name = ('scalar-date','scalar-year','scalar-yearmonth','scalar-datetime')"/>
            <xsl:variable name="type-is-scalar-nonempty" select="imvert:type-name = ('scalar-postcode')"/>
            <xsl:variable name="type-is-enumeration" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-enumeration')"/>
            
            <xsl:variable name="type-is-external" select="exists(imvert:conceptual-schema-type)"/>
         
            <xsl:variable name="facet-length" select="imvert:max-length"/>
            <xsl:variable name="facet-pattern" select="imf:get-most-relevant-compiled-taggedvalue(.,'Formeel patroon')"/>
            <xsl:variable name="facet-minval" select="imf:get-most-relevant-compiled-taggedvalue(.,'Minimum waarde (inclusief)')"/>
            <xsl:variable name="facet-maxval" select="imf:get-most-relevant-compiled-taggedvalue(.,'Maximum waarde (inclusief)')"/>
            
            <xsl:variable name="type-has-facets" select="exists(($facet-pattern, $facet-length,$facet-minval,$facet-maxval))"/>
            
            <xsl:sequence select="imf:create-comment(concat('mode-local-attribute Local attribute # ',@display-name))"/>
            
            <xsl:variable name="scalar-att-type" select="imf:get-stuf-scalar-attribute-type(.)"/>
            
            <xsl:choose>
                <xsl:when test="$type-is-scalar-empty">
                    <xsl:sequence select="imf:create-comment('Scalar en kan leeg worden')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$scalar-att-type}" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:when>
                
                <xsl:when test="$type-is-scalar-nonempty">
                    <xsl:sequence select="imf:create-comment('Scalar en kan niet leeg')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="TODO" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:when>
                
                <xsl:when test="$type-is-enumeration">
                    <xsl:sequence select="imf:create-comment('Een enumeratie')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$prefix}:{imf:capitalize($compiled-name-type)}-e" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:when>
                
                <!-- TODO type is tabel entiteit -->
                <xsl:when test="exists($applicable-attribute)">
                    
                    <xsl:sequence select="imf:create-comment('Attribute redirected to referentie tabel')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$prefix}:{imf:capitalize($applicable-compiled-name)}-e" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                        <xsl:if test="$type-is-scalar-base or $type-has-facets">
                            <xsl:attribute name="nillable">true</xsl:attribute>
                        </xsl:if>
                    </xs:element>
                </xsl:when>
                
                
                <xsl:when test="$type-is-complextype"><!-- DONE Complex datatype niet goed geïmplementeerd -->
                    <xsl:sequence select="imf:create-comment('Een complex datatype')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$prefix}:{imf:capitalize($compiled-name-type)}-e" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:when>
                
                <xsl:when test="$type-is-external"><!-- DONE (VERPLAATST) Generieke datatypen niet goed geïmplementeerd -->
                    <xsl:sequence select="imf:create-comment('Een extern type')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$prefix}:{imf:capitalize($compiled-name)}" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:when>
                
                <!-- else: -->
                
                <xsl:when test="$type-is-simpletype">
                    <xsl:sequence select="imf:create-comment('Een simpel datatype')"/> 
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$prefix}:{imf:capitalize($applicable-compiled-name)}-e" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:when>
                
                <xsl:otherwise>
                    <xsl:sequence select="imf:create-comment('Scalar maar niet in de onderlaag')"/>
                    <xs:element
                        name="{$compiled-name}" 
                        type="{$prefix}:{imf:capitalize($applicable-compiled-name)}-e" 
                        minOccurs="0" 
                        maxOccurs="{$cardinality[4]}"
                        >
                        <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                    </xs:element>
                </xsl:otherwise>
            </xsl:choose>
            
        </xsl:for-each>
       
    </xsl:template>
    
    <xsl:function name="imf:get-external-type-name">
        <xsl:param name="attribute"/>
        <xsl:param name="as-type" as="xs:boolean"/>
        <!-- determine the name; hard koderen -->
        <xsl:for-each select="$attribute"> <!-- singleton -->
            <xsl:choose>
                <xsl:when test="imvert:type-package='GML3'">
                    <xsl:variable name="type-suffix" select="if ($as-type) then 'Type' else ''"/>
                    <xsl:variable name="type-prefix">
                        <xsl:choose>
                            <xsl:when test="empty(imvert:conceptual-schema-type)">
                                <xsl:sequence select="imf:msg(.,'ERROR','No conceptual schema type specified',())"/>
                            </xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Point'">gml:Point</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Curve'">gml:Curve</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Surface'">gml:Surface</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiPoint'">gml:MultiPoint</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiSurface'">gml:MultiSurface</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiCurve'">gml:MultiCurve</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Geometry'">gml:Geometry</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiGeometry'">gml:MultiGeometry</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_ArcString'">gml:ArcString</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_LineString'">gml:LineString</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Polygon'">gml:Polygon</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Object'">gml:GeometryProperty</xsl:when><!-- see http://www.geonovum.nl/onderwerpen/geography-markup-language-gml/documenten/handreiking-geometrie-model-en-gml-10 -->
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Primitive'">gml:Primitive</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Position'">gml:Position</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_PointArray'">gml:PointArray</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_Solid'">gml:Solid</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_OrientableCurve'">gml:OrientableCurve</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_OrientableSurface'">gml:OrientableSurface</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_CompositePoint'">gml:CompositePoint</xsl:when>
                            <xsl:when test="imvert:conceptual-schema-type = 'GM_MultiSolid'">gml:MultiSolid</xsl:when>
                            <xsl:otherwise>
                                <xsl:sequence select="imf:msg(.,'ERROR','Cannot handle the GML type [1]', imvert:conceptual-schema-type)"/>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:variable>
                    <xsl:value-of select="concat($type-prefix,$type-suffix)"/>
               </xsl:when>
                <xsl:when test="empty(imvert:type-package)">
                    <!-- TODO -->
                </xsl:when>
                <xsl:otherwise>
                    <!-- geen andere externe packages bekend -->
                    <xsl:sequence select="imf:msg(.,'ERROR','Cannot handle the external package [1]', imvert:type-package)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:for-each>
        
    </xsl:function>
    
    <xsl:template match="imvert:attribute" mode="mode-local-data-element">
        <xsl:apply-templates select="." mode="mode-local-attribute"/>
        <!--XX
            
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-data-element Local data element # ',@display-name))"/>
        
        <xsl:variable name="stuf-scalar-att-type" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:choose>
            <xsl:when test="exists($stuf-scalar-att-type)">
                <xsl:sequence select="imf:create-comment('In de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{$stuf-scalar-att-type}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                />
            </xsl:when>
            <xsl:when test="empty($type)">
                <xsl:sequence select="imf:create-comment('Simple type, niet in de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name))}-e" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
                
            </xsl:when>
            <xsl:when test="$type[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-enumeration')]">
                <xsl:sequence select="imf:create-comment('Enumeratie')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name-type))}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                     >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
                
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment('Niet simpel datatype, niet in de onderlaag')"/>
                <xs:element
                    name="{$compiled-name}" 
                    type="{concat($prefix, ':', imf:capitalize($compiled-name-type),'-e')}" 
                    minOccurs="0" 
                    maxOccurs="{$cardinality[4]}"
                    >
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:otherwise>
        </xsl:choose>
        XX-->
        
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-local-enum">
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-attribute Local enum # ',@display-name))"/>
        
        <xs:enumeration value="{imvert:name}">
            <xsl:sequence select="imf:create-annotation(.)"/>
        </xs:enumeration>
        
    </xsl:template>

    <!-- de weergave van een enkele keuze -->
    <xsl:template match="imvert:attribute" mode="mode-local-union-element">
        <xsl:apply-templates select="." mode="mode-local-attribute"/>
       <!--XX
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-is-external" select="exists(imvert:conceptual-schema-type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-union-element Local union element # ',@display-name))"/>
        
        <xsl:variable name="type-ref">
            <xsl:choose>
                <xsl:when test="$type-is-external">
                    <xsl:value-of select="imf:get-external-type-name(.,false())"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="imf:get-compiled-name($type)"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        
        <xs:element
            ref="{$type-ref}" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
        />
        XX-->
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-local-referentielijst-element">
        <xsl:apply-templates select="." mode="mode-local-attribute"/>
        <!--XX
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-attribute Local referentielijst element # ',@display-name))"/>
        
        <xs:element
            name="{$compiled-name}" 
            type="{concat($prefix, ':', imf:capitalize($compiled-name),'-e')}" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
        />
        XX-->
        
    </xsl:template>
    
    <!-- dit betreft echte relaties, dus geen composities -->
    <xsl:template match="imvert:association" mode="mode-local-association">
        <xsl:param name="kerngegevens" select="false()"/>
        <xsl:param name="richting" select="'uitgaand'"/>
        
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert:class"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        
        <xsl:variable name="assoc-name" select="concat(imvert:name,imf:capitalize($target/imvert:name))"/>
        <xsl:choose>
            <xsl:when test="$richting = 'uitgaand'">
                <xsl:sequence select="imf:create-comment(concat('mode-local-association Uitgaande relatie # ',@display-name))"/>
                
                <xsl:variable name="heen-typeref" select="concat($prefix, ':', imvert:alias,if ($kerngegevens) then '-kerngegevens' else '-basis')"/>
                
                <xsl:variable name="has-form-his" select="$history[1]"/>
                <xsl:variable name="has-mat-his" select="$history[2]"/>
                
                <xsl:variable name="target-cardinality" select="if ($has-mat-his and not($has-form-his)) then 'unbounded' else $cardinality[4]"/> <!-- als materiele historie en niet formeel, dan is target altijd unbounded -->
                <xs:element
                    name="{$assoc-name}" 
                    type="{$heen-typeref}" 
                    minOccurs="0" 
                    maxOccurs="{$target-cardinality}"
                    > <!-- must be 0, fixed -->
                    <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
                </xs:element>
            </xsl:when>
            <xsl:otherwise>
               <!-- er hoeft geen terugrelatie te worden gegenereerd -->
            </xsl:otherwise>
        </xsl:choose>
    
    </xsl:template>
    
    <!-- dit betreft gegevensgroepen, dus composities -->
    <xsl:template match="imvert:association" mode="mode-local-composition">
        <xsl:param name="kerngegevens" select="false()"/>

        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="cardinality" select="imf:get-cardinality(.)"/>
        <xsl:variable name="history" select="imf:get-history(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-local-composition Association # ',@display-name))"/>
        
        <xs:element
            name="{$compiled-name}" 
            type="{concat($prefix, ':', $compiled-name-type)}-basis" 
            minOccurs="0" 
            maxOccurs="{$cardinality[4]}"
            >
            <xsl:sequence select="imf:create-historie-attributes($history[1],$history[2])"/>
        </xs:element>
        
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-type">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="compiled-name-type" select="imf:get-compiled-name($type)"/>
     
        <xsl:variable name="type-stereotype" select="imf:get-stereotype($type)"/>
        <xsl:variable name="stuf-scalar-att-type" select="imf:get-stuf-scalar-attribute-type(.)"/>
        <xsl:variable name="is-enumeration" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-enumeration')"/>
        <xsl:variable name="type-is-referentietabel" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-referentielijst')"/>
        <xsl:variable name="type-is-complextype" select="imf:get-stereotype($type) = imf:get-config-stereotypes('stereotype-name-complextype')"/>
        
        <xsl:choose>
            <xsl:when test="$is-enumeration">
               <!-- handled by separate mnode -->
            </xsl:when>
            <xsl:when test="$type-is-referentietabel">
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-type Tabel entiteit # ',@display-name))"/>
                <!-- when referentietabel, assume the attribute is the is-id attribute of the referentie tabel -->
                <xsl:variable name="applicable-attribute" select="$type//imvert:attribute[imf:boolean(imvert:is-id)]"/>
                <xsl:variable name="applicable-attribute-name" select="imf:get-compiled-name($applicable-attribute)"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}-e">
                    <xs:choice>
                        <xs:element name="w" type="{$prefix}:{imf:capitalize($applicable-attribute-name)}-e"/>
                        <xs:element name="l" type="{$StUF-prefix}:NoValue"/>
                    </xs:choice>
                </xs:complexType>
            </xsl:when>
            <xsl:when test="$type-is-complextype">
                <!-- handled by separate mode -->
            </xsl:when>
            <xsl:when test="empty($stuf-scalar-att-type)">
                    <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-type Attribute declaration # ',@display-name))"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}-e">
                    <xs:choice>
                        <xs:element name="w" type="{$prefix}:{imf:capitalize($compiled-name)}"/>
                        <xs:element name="l" type="{$StUF-prefix}:NoValue"/>
                    </xs:choice>
                </xs:complexType>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-type Attribute is in onderlaag # ',@display-name))"/>
            </xsl:otherwise>
        </xsl:choose>
            
    </xsl:template>
    
    <xsl:template match="imvert:association" mode="mode-global-association-type">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="source" select="ancestor::imvert:class"/>
        
        <xsl:variable name="target" select="imf:get-class(.)"/>
        
        <xsl:variable name="hisform-on-association" select="imf:get-history(.)[1]"/>
        <xsl:variable name="hismate-on-association" select="imf:get-history(.)[2]"/>
        
        <xsl:variable name="association-class" select="imf:get-by-id(imvert:association-class/imvert:type-id)"/>
        <xsl:variable name="association-class-attributes" select="$association-class//imvert:attribute"/>
        <xsl:variable name="association-class-associations" select="$association-class//imvert:association[not(imvert:aggregation = 'composite')]"/>
        <xsl:variable name="association-class-compositions" select="$association-class//imvert:association[imvert:aggregation = 'composite']"/>
        
        <xsl:variable name="hisform-on-association-class" select="imf:get-history($association-class)[1]"/>
        <xsl:variable name="hismate-on-association-class" select="imf:get-history($association-class)[2]"/>
        
        <xsl:variable name="suffix" select="imf:get-relation-suffix(.)"/>
        
        <xsl:variable name="source-alias" select="imvert:source-alias"/>
        <xsl:variable name="target-alias" select="imvert:target-alias"/>
       
        <xsl:variable name="target-is-supertype-label" select="if (exists(imf:get-subclasses($target))) then '-super' else '-basis'"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-association-type Outgoing Association declaration # ',@display-name))"/>
    
        <xsl:variable name="associatie-naam" select="imvert:alias"/>
        
        <xs:complexType name="{$associatie-naam}-basis">
            <xsl:sequence select="imf:create-annotation(.)"/>
            <xs:choice>
                <xs:element ref="{$StUF-prefix}:leeg"/>
                <xs:sequence>
                    <xs:element 
                        name="gerelateerde" 
                        type="{$prefix}:{$target/imvert:alias}{$target-is-supertype-label}"
                        minOccurs="0"/>
                    
                    <!-- add the attributes & associations of the association class, if any -->
                    
                    <xsl:sequence select="imf:create-comment('mode-global-association-type (Attributes)')"/>
                    <xsl:apply-templates select="$association-class-attributes" mode="mode-local-attribute"/>
                    
                    <xsl:sequence select="imf:create-comment('mode-global-association-type (Compositie relaties)')"/>
                    <xsl:apply-templates select="$association-class-compositions" mode="mode-local-composition">
                        <xsl:sort select="imvert:name"/>
                    </xsl:apply-templates>
                    
                    <xsl:if test="imf:is-authentiek(.)">
                        <!-- avoid duplicates -->
                        <xs:element name="authentiek" type="{$StUF-prefix}:StatusMetagegeven-basis" minOccurs="0" maxOccurs="unbounded"/><!-- DONE bg:authentiek-TODO -->
                    </xsl:if>
                    <xsl:if test="imf:is-in-onderzoek(.)">
                        <xs:element name="inOnderzoek" type="{$StUF-prefix}:StatusMetagegeven-basis" minOccurs="0" maxOccurs="unbounded"/>
                    </xsl:if>
                    
                    <xsl:if test="$hismate-on-association"><!-- DONE HeeftAlsKind heeft geen materiele historie -->
                        <xs:element ref="{$StUF-prefix}:tijdvakRelatie" minOccurs="0"/>                        
                    </xsl:if>
                    
                    <xs:element ref="{$StUF-prefix}:tijdvakGeldigheid" minOccurs="0"/>     
                    <xs:element ref="{$StUF-prefix}:tijdstipRegistratie" minOccurs="0"/>

                    <xs:element ref="{$StUF-prefix}:extraElementen" minOccurs="0"/>
                    <xs:element ref="{$StUF-prefix}:aanvullendeElementen" minOccurs="0"/>
                    
                    <xsl:if test="exists($association-class) and $hismate-on-association">
                        <xs:element name ="historieMaterieel" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}" 
                            minOccurs="0"     
                            maxOccurs="unbounded"/>
                    </xsl:if>
                    <xsl:if test="exists($association-class) and $hisform-on-association">
                        <xs:element name="historieFormeel" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                            minOccurs="0"/>  
                    </xsl:if>
                    <xsl:if test="empty($association-class) and $hisform-on-association">
                        <xs:element name="historieFormeelRelatie" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                            minOccurs="0"/>  
                    </xsl:if>
                    <xsl:if test="empty($association-class) and $hismate-on-association"><!-- DONE HeeftAlsKind heeft geen materiele historie -->
                        <xs:element name="historieMaterieelRelatie" 
                            type="{concat($prefix, ':', $associatie-naam,'-basis')}"  
                            minOccurs="0"/>  
                    </xsl:if>
                    
                    <xsl:apply-templates select="$association-class-associations" mode="mode-local-association"/>
         
                </xs:sequence>
            </xs:choice>
            <xs:attribute ref="{$StUF-prefix}:entiteittype" fixed="{imvert:alias}"/>
            <xs:attributeGroup ref="{$StUF-prefix}:entiteit"/>
        </xs:complexType>
        
        <xsl:if test="true()"><!--TODO was: exists(imvert:is-id) , wordt ewellicht : heeft indicatie kerngegeven yes. -->
            <xsl:sequence select="imf:create-comment(concat('mode-global-association-type Outgoing Association kerngegevens # ',@display-name))"/>
            
            <xs:complexType name="{$associatie-naam}-kerngegevens">
                <xs:annotation>
                    <xs:documentation>Kerngegevens van de relatie</xs:documentation>
                </xs:annotation>
                <xs:complexContent>
                    <xs:restriction base="{$prefix}:{$associatie-naam}-basis">
                        <xs:sequence>
                            <xs:element 
                                name="gerelateerde" 
                                type="{$prefix}:{$target/imvert:alias}-kerngegevens"
                                />
                        </xs:sequence>
                        <xs:attribute name="entiteittype" fixed="{imvert:alias}" use="required"/>
                        <xs:attribute ref="{$StUF-prefix}:noValue" use="prohibited"/>
                        <xs:attribute ref="{$StUF-prefix}:scope" use="prohibited"/>
                    </xs:restriction>
                </xs:complexContent>
            </xs:complexType>
        </xsl:if>
        
     </xsl:template>
    
    <!-- called only with attributes that have no type-id -->
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-simpletype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="stuf-scalar" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:variable name="max-length" select="imvert:max-length"/>
        <xsl:variable name="total-digits" select="imvert:total-digits"/>
        <xsl:variable name="fraction-digits" select="imvert:fraction-digits"/>
        
        <xsl:variable name="min-waarde" select="imf:get-taggedvalue(.,'Minimum waarde (inclusief)')"/>
        <xsl:variable name="max-waarde" select="imf:get-taggedvalue(.,'Maximum waarde (inclusief)')"/>
        <xsl:variable name="min-length" select="imf:get-taggedvalue(.,'Minimum lengte')"/>
        <xsl:variable name="patroon" select="imf:get-taggedvalue(.,'Formeel patroon')"/>
        
        <xsl:variable name="facetten">
            <xsl:sequence select="imf:create-facet('xs:pattern',$patroon)"/>
            <xsl:sequence select="imf:create-facet('xs:minInclusive',$min-waarde)"/>
            <xsl:sequence select="imf:create-facet('xs:maxInclusive',$max-waarde)"/>
            <xsl:sequence select="imf:create-facet('xs:minLength',$min-length)"/>
            <xsl:sequence select="imf:create-facet('xs:maxLength',$max-length)"/>
            <xsl:sequence select="imf:create-facet('xs:totalDigits',$total-digits)"/>
            <xsl:sequence select="imf:create-facet('xs:fractionDigits',$fraction-digits)"/>
        </xsl:variable>
        
        <xsl:choose>
            <xsl:when test="exists($stuf-scalar)">
                <!-- gedefinieerd in onderlaag -->
            </xsl:when>
            <xsl:when test="exists(imvert:type-name)">
                
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-simpletype Attribuut type (simple) # ',@display-name))"/>
                
                <xs:simpleType name="{imf:capitalize($compiled-name)}">
                    <xsl:choose>
                        <xsl:when test="imvert:type-name = 'scalar-integer'">
                            <xs:restriction base="xs:integer">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-string'">
                            <xs:restriction base="xs:string">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-decimal'">
                            <xs:restriction base="xs:decimal">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-boolean'">
                            <xs:restriction base="xs:boolean">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-date'">
                            <xs:restriction base="xs:dateTime">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-txt'">
                            <xs:restriction base="xs:string">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>    
                        <xsl:when test="imvert:type-name = 'scalar-uri'">
                            <xs:restriction base="xs:anyURI">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-indic'">
                            <xs:restriction base="xs:boolean"/>
                        </xsl:when>
                        <xsl:when test="imvert:type-name = 'scalar-postcode'">
                            <xs:restriction base="{$StUF-prefix}:postcode">
                                <xsl:sequence select="$facetten"/>
                            </xs:restriction>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:sequence select="imf:msg(.,'ERROR','Cannot handle the simple attribute type: [1]', imvert:type-name)"/>
                        </xsl:otherwise>                
                    </xsl:choose>
                </xs:simpleType>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    
    <!-- called only with attributes that have a type-id -->
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-niet-simpletype">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="type" select="imf:get-class(.)"/>
        <xsl:variable name="type-stereo" select="imf:get-stereotype($type)"/>
        <xsl:variable name="compiled-type-name" select="imf:get-compiled-name($type)"/>
        
        <xsl:variable name="type-is-complextype" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-complextype')"/>
        <xsl:variable name="type-is-referentietabel" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-referentielijst')"/>
        <xsl:variable name="type-is-enumeration" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-enumeration')"/>
        <xsl:variable name="type-is-union" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-union')"/>
        <xsl:variable name="type-is-interface" select="$type-stereo = imf:get-config-stereotypes('stereotype-name-interface')"/>
        
        <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-niet-simpletype Attribuut type (not simple) # ',@display-name))"/>
        
        <xsl:choose>
            <xsl:when test="$type-is-complextype"><!-- DONE removed: Complex datatype niet goed geïmplementeerd -->
                <!--
                <xsl:sequence select="imf:create-comment('Type is complex datatype')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name))}"/>
                    </xs:complexContent>
                </xs:complexType>
                -->
            </xsl:when>
            <xsl:when test="$type-is-referentietabel">
                <xsl:sequence select="imf:create-comment('Type is referentie tabel')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name),'-basis')}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <!--xx
            <xsl:when test="$type-is-enumeration">
                <xsl:sequence select="imf:create-comment('Type is enumeration')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}-e">
                    <xs:simpleContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name))}"/>
                    </xs:simpleContent>
                </xs:complexType>
            </xsl:when>
            xx-->
            <xsl:when test="$type-is-union">
                <xsl:sequence select="imf:create-comment('Type is union')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-type-name))}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <xsl:when test="$type-is-interface">
                <xsl:sequence select="imf:create-comment('Type is interface')"/>
                <xs:complexType name="{imf:capitalize($compiled-name)}">
                    <xs:complexContent>
                        <xs:extension base="{imf:get-external-type-name(.,true())}"/>
                    </xs:complexContent>
                </xs:complexType>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('TODO Geen bekend type: ',$type-stereo))"/>
            </xsl:otherwise>
        </xsl:choose>
         
    </xsl:template>
    
    <xsl:template match="imvert:attribute" mode="mode-global-attribute-referentie-element">
        <xsl:variable name="compiled-name" select="imf:get-compiled-name(.)"/>
        
        <xsl:variable name="stuf-scalar" select="imf:get-stuf-scalar-attribute-type(.)"/>
        
        <xsl:choose>
            <xsl:when test="exists($stuf-scalar)">
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-referentie-element Referentie element 1 # ',imvert:name/@original))"/>
       
                <xs:simpleType name="{concat(imf:capitalize($compiled-name),'-e')}"> <!-- ESW -->
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xs:restriction base="{$stuf-scalar}"/>
                </xs:simpleType>
                
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:create-comment(concat('mode-global-attribute-referentie-element Referentie element 2 # ',imvert:name/@original))"/>
                
                <xs:complexType name="{concat(imf:capitalize($compiled-name),'-e')}"><!-- ESW -->
                    <xsl:sequence select="imf:create-annotation(.)"/>
                    <xs:simpleContent>
                        <xs:extension base="{concat($prefix,':',imf:capitalize($compiled-name))}">
                            <xs:attributeGroup ref="{$StUF-prefix}:element"/>
                        </xs:extension>
                    </xs:simpleContent>
                </xs:complexType>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:template>
      
    <xsl:function name="imf:get-compiled-name">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="type" select="local-name($this)"/>
        <xsl:variable name="stereotype" select="imf:get-stereotype($this)"/>
        <xsl:variable name="alias" select="$this/imvert:alias"/>
        <xsl:variable name="name-raw" select="$this/imvert:name"/>
        <xsl:variable name="name-form" select="replace($name-raw,'[^\p{L}0-9.\-]+','_')"/>
        <!--XX
        <xsl:variable name="name">
            <xsl:choose>
                <xsl:when test="$type = 'attribute' and $name-form = ('soort','code','sbiCode','voorvoegsel','scheidingsteken')"><!- -TODO this is a patch - ->
                    <xsl:variable name="class" select="$this/ancestor::imvert:class"/>
                    <xsl:value-of select="concat(imf:get-compiled-name($class),'_',$name-form)"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="$name-form"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        XX-->
        <xsl:variable name="name" select="$name-form"/>
        
        <xsl:choose>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-composite')">
                <xsl:value-of select="concat(imf:capitalize($name),'Grp')"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-objecttype')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-relatieklasse')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-referentielijst')">
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-complextype')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-enumeration')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-union')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'class' and $stereotype = imf:get-config-stereotypes('stereotype-name-interface')">
                <!-- this must be an external -->
                <xsl:variable name="external-name" select="imf:get-external-type-name($this,true())"/>
                <xsl:value-of select="$external-name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-attribute')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-referentie-element')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-data-element')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-enum')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'attribute' and $stereotype = imf:get-config-stereotypes('stereotype-name-union-element')">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $stereotype = 'relatiesoort' and normalize-space($alias)">
                <!-- if this relation occurs multiple times, add the alias of the target object -->
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $this/imvert:aggregation = 'composite'">
                <xsl:value-of select="$name"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and $stereotype = 'relatiesoort'">
                <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                <xsl:value-of select="lower-case($name)"/>
            </xsl:when>
            <xsl:when test="$type = 'association' and normalize-space($alias)"> <!-- composite -->
                <xsl:value-of select="$alias"/>
            </xsl:when>
            <xsl:when test="$type = 'association'">
                <xsl:sequence select="imf:msg($this,'ERROR','No alias',())"/>
                <xsl:value-of select="lower-case($name)"/>
            </xsl:when>
            <!-- TODO meer soorten namen uitwerken? -->
            <xsl:otherwise>
                <xsl:sequence select="imf:msg($this,'ERROR','Unknown type [1] with stereo [2]', ($type, string-join($stereotype,', ')))"/>
            </xsl:otherwise>
        </xsl:choose>
        
    </xsl:function>
    
    <xsl:function name="imf:get-cardinality" as="xs:string+">
        <xsl:param name="this"/>
        <xsl:variable name="source-min" select="$this/imvert:min-occurs-source"/>
        <xsl:variable name="source-max" select="$this/imvert:max-occurs-source"/>
        <xsl:variable name="target-min" select="$this/imvert:min-occurs"/>
        <xsl:variable name="target-max" select="$this/imvert:max-occurs"/>
        <xsl:sequence select="(normalize-space($source-min),normalize-space($source-max),normalize-space($target-min),normalize-space($target-max))"/>
    </xsl:function>
    
    <!-- 
        return (formal?, material?) boolean values 
    
        if this is a composition to a group, inspect the group history 
    -->
    <xsl:function name="imf:get-history" as="xs:boolean+">
        <xsl:param name="this"/>
        <xsl:variable name="formal-this" select="imf:get-most-relevant-compiled-taggedvalue($this,'Indicatie formele historie')"/>
        <xsl:variable name="formal-grp" select="imf:get-most-relevant-compiled-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie formele historie')"/>
        <xsl:variable name="formal" select="if ($formal-this = 'ZIEGROEP') then $formal-grp else $formal-this"/>
        <xsl:variable name="material-this" select="imf:get-most-relevant-compiled-taggedvalue($this,'Indicatie materiële historie')"/>
        <xsl:variable name="material-grp" select="imf:get-most-relevant-compiled-taggedvalue(imf:get-groepattribuutsoort($this),'Indicatie materiële historie')"/>
        <xsl:variable name="material" select="if ($material-this = 'ZIEGROEP') then $material-grp else $material-this"/>
        <xsl:sequence select="(imf:boolean($this,$formal),imf:boolean($this,$material))"/>
    </xsl:function>

    <!-- true when: 
        Alleen als één van de elementen of groepen een ‘Indicatie authentiek’ gelijk aan Authentiek, Landelijk kerngegeven, 
        Gemeentelijk kerngegeven of Overig heeft 
    -->
    <xsl:function name="imf:is-authentiek" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:variable name="elements" select="imf:get-all-attributes($this)"/>
        <xsl:variable name="bools" as="xs:boolean*">
            <xsl:for-each select="$elements">
                <!-- see if any or the relevant tagged values for this attribute is authentic -->
                <xsl:variable name="tv" select="imf:get-most-relevant-compiled-taggedvalue(.,'Indicatie authentiek')"/>
                <xsl:sequence select="$tv = ('Authentiek', 'Landelijk kerngegeven','Gemeentelijk kerngegeven','Overig')"/>
            </xsl:for-each>
        </xsl:variable>
        <xsl:sequence select="imf:boolean-or($bools)"/>   
    </xsl:function>     
   
    <!-- true when: 
       TODO
    -->
    <xsl:function name="imf:is-gebeurtenis" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:sequence select="true()"/>   
    </xsl:function>     
    
    <xsl:function name="imf:get-stereotype" as="xs:string*">
        <xsl:param name="this"/>
        <xsl:sequence select="$this/imvert:stereotype"/>
    </xsl:function>

    <xsl:function name="imf:get-taggedvalue" as="xs:string?">
        <xsl:param name="this"/>
        <xsl:param name="name"/>
        <xsl:value-of select="$this/imvert:tagged-values/imvert:tagged-value[imvert:name = $name]/imvert:value"/>
    </xsl:function>
    
    <xsl:function name="imf:get-groepattribuutsoort" as="element()?">
        <xsl:param name="this" as="element()"/>
        <xsl:sequence select="$this/ancestor-or-self::imvert:class[imf:get-stereotype(.) = imf:get-config-stereotypes('stereotype-name-composite')]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-documentation">
        <xsl:param name="this"/>
        <xsl:value-of select="normalize-space($this/imvert:documentation)"/>
    </xsl:function>
    
    <!-- tools -->
    
    <xsl:function name="imf:capitalize">
        <xsl:param name="name"/>
        <xsl:value-of select="concat(upper-case(substring($name,1,1)),substring($name,2))"/>
    </xsl:function>
    
    <xsl:function name="imf:boolean" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:param name="value"/>
        <xsl:sequence select="starts-with($value,'J')"/><!-- DONE Attribute metadata:materieleHistorie="true" ontbreekt -->
    </xsl:function>

    <!-- 
        ============================================== 
        common for all model based stylesheets 
        ============================================== 
    -->
    
    <xsl:function name="imf:get-construct-name" as="item()*">
        <xsl:param name="this" as="element()"/>
        <xsl:variable name="name" select="imf:sub-name($this)"/>
        <xsl:variable name="package-name" select="imf:sub-name($this/ancestor-or-self::imvert:package[1])"/>
        <xsl:variable name="class-name" select="imf:sub-name($this/ancestor-or-self::imvert:class[1])"/>
        <xsl:choose>
            <xsl:when test="$this/self::imvert:package">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:base">
                <xsl:sequence select="imf:compile-construct-name($name,'','','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:class">
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:type">
                <xsl:sequence select="imf:compile-construct-name($this/imvert:type-package,$this/imvert:type-name,'','')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:attribute">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'attrib')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:association[not(imf:sub-name(.))]">
                <xsl:variable name="type" select="concat('[',$this/imvert:type-name,']')"/>
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$type,'aggr')"/>
            </xsl:when>
            <xsl:when test="$this/self::imvert:association">
                <xsl:sequence select="imf:compile-construct-name($package-name,$class-name,$name,'assoc')"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:sequence select="imf:compile-construct-name($package-name,$name,local-name($this),'')"/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:function>
    
    <xsl:function name="imf:sub-name">
        <xsl:param name="this"/>
        <xsl:value-of select="$this/imvert:name"/>
    </xsl:function>

    <xsl:function name="imf:get-class" as="element()?">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:type-id"/>
        <xsl:if test="normalize-space($id)">
            <xsl:variable name="class" select="root($this)//imvert:class[imf:get-id(.) = $id]"/>
            <xsl:sequence select="$class"/>
        </xsl:if>
    </xsl:function>

    <xsl:function name="imf:stub-create-name">
        <xsl:param name="literal-name"/>
        <xsl:value-of select="concat('STUB-',replace($literal-name,'[^a-zA-Z]','_'))"/>
    </xsl:function>

    <xsl:function name="imf:parse-names" as="xs:string*">
        <xsl:param name="text" as="xs:string"/>
        <xsl:analyze-string select="$text" regex="'(.+?)'">
            <xsl:matching-substring>
                <xsl:value-of select="regex-group(1)"/>
            </xsl:matching-substring>
        </xsl:analyze-string>
    </xsl:function>
    
    <xsl:function name="imf:get-by-id" as="element()?">
        <xsl:param name="id"/>
        <xsl:sequence select="$document//*[imf:get-id(.) = $id]"/>
    </xsl:function>
    
    <xsl:function name="imf:get-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- get the ID of the type of the attribute or association -->
    <xsl:function name="imf:get-type-id" as="xs:string">
        <xsl:param name="this"/>
        <xsl:variable name="id" select="$this/imvert:type-id"/>
        <xsl:value-of select="$id"/>
    </xsl:function>
    
    <!-- return suffixes to append to relation names. [1] is incoming, [2] is outgoing -->
    <xsl:function name="imf:get-relation-suffix" as="xs:string+">
        <xsl:param name="this"/> <!-- an Association element -->
        <xsl:variable name="targetAlias" select="$this/imvert:target-alias"/>
        <xsl:variable name="targetId" select="imf:get-type-id($this)"/>
        
        <xsl:variable name="other-associations" select="root($this)//imvert:association[imvert:target-alias = $targetAlias and imf:get-type-id(.) = $targetId]"/>
        <xsl:variable name="class" select="$this/ancestor::imvert:class"/>
        <xsl:value-of select="if (count($other-associations) gt 1) then imf:capitalize($class/imvert:name) else ''"/>

        <xsl:variable name="class" select="root($this)//imvert:class[imf:get-id(.) = $targetId]"/>
        <xsl:value-of select="if (count($this/../imvert:association[imvert:target-alias = $targetAlias]) gt 1) then imf:capitalize($class/imvert:name) else ''"/>

    </xsl:function>
    
    <xsl:function name="imf:create-annotation">
        <xsl:param name="this"/>
        <xsl:variable name="doc" select="imf:get-documentation($this)"/>
        <xsl:if test="normalize-space($doc)">
            <xs:annotation>
                <xs:documentation>
                    <xsl:value-of select="concat($this/imvert:name/@original, ': ', $doc)"/>
                </xs:documentation>
            </xs:annotation>
        </xsl:if>
    </xsl:function>
    
    <!-- deze scalars kunnen meteen uit de StUF onderlaag worden gehaald -->
    <xsl:function name="imf:get-stuf-scalar-attribute-type" as="xs:string?">
        <xsl:param name="attribute"/>
   
        <xsl:choose>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-date' and $attribute/imvert:type-modifier = '?'">
                <xsl:value-of select="concat($StUF-prefix,':DatumMogelijkOnvolledig-e')"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-date'">
                <xsl:value-of select="concat($StUF-prefix,':Datum-e')"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-datetime' and $attribute/imvert:type-modifier = '?'">
                <xsl:value-of select="concat($StUF-prefix,':TijdstipMogelijkOnvolledig-e')"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-datetime'">
                <xsl:value-of select="concat($StUF-prefix,':Tijdstip-e')"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-year'">
                <xsl:value-of select="concat($StUF-prefix,':Jaar-e')"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-yearmonth'">
                <xsl:value-of select="concat($StUF-prefix,':JaarMaand-e')"/>
            </xsl:when>
            <xsl:when test="$attribute/imvert:type-name = 'scalar-postcode'">
                <xsl:value-of select="concat($StUF-prefix,':Postcode-e')"/>
            </xsl:when>
        </xsl:choose>
    
    </xsl:function>
    
    <xsl:function name="imf:create-comment" as="comment()?">
        <xsl:param name="text"/>
        <xsl:if test="$debugging">
            <xsl:comment select="$text"/>
        </xsl:if>
    </xsl:function>
    
    <xsl:function name="imf:create-facet" as="element()?">
        <xsl:param name="elementname"/>
        <xsl:param name="content"/>
        <xsl:if test="normalize-space($content)">
            <xsl:element name="{$elementname}">
                <xsl:attribute name="value" select="$content"/>
            </xsl:element>
        </xsl:if>
    </xsl:function>
    
    <xsl:function name="imf:get-external-element-name">
        <xsl:param name="conceptual-schema-namespace"/>
        <xsl:param name="conceptual-schema-class-name"/>
        
    </xsl:function>
    
    <xsl:function name="imf:is-in-onderzoek" as="xs:boolean">
        <xsl:param name="this"/>
        <xsl:variable name="elements" select="imf:get-all-attributes($this)"/>
        <xsl:variable name="bools" as="xs:boolean*">
            <xsl:for-each select="$elements">
                <!-- see if any or the relevant tagged values for this attribute is authentic -->
                <xsl:variable name="tv" select="imf:get-most-relevant-compiled-taggedvalue(.,'Indicatie in onderzoek')"/>
                <xsl:sequence select="$tv = ('Ja')"/>
                <xsl:sequence select="($tv = ('Zie groep')) and imf:get-most-relevant-compiled-taggedvalue(../..,'Indicatie in onderzoek')"/>
            </xsl:for-each>
        </xsl:variable>
        <xsl:sequence select="imf:boolean-or($bools)"/>   
    </xsl:function>        
    
    <xsl:function name="imf:create-historie-attributes" as="attribute()*">
        <xsl:param name="formeel"/>
        <xsl:param name="materieel"/>
        <xsl:if test="imf:boolean($formeel)">
            <xsl:attribute name="metadata:formeleHistorie" select="$formeel"/>
        </xsl:if>
        <xsl:if test="imf:boolean($materieel)">
            <xsl:attribute name="metadata:materieleHistorie" select="$materieel"/>
        </xsl:if>
    </xsl:function>
    
    <!-- get all attributes defined on the class, group or any composite group -->
    <xsl:function name="imf:get-all-attributes" as="element(imvert:attribute)*">
        <xsl:param name="this"/>
        <xsl:sequence select="$this/*/imvert:attribute"/>
       
        <xsl:variable name="group-type-ids" select="$this/*/imvert:association[imvert:aggregation = 'composite']/imvert:type-id"/>
        <xsl:variable name="groups" select="for $id in $group-type-ids return imf:get-construct-by-id($id)"/>
        <xsl:sequence select="for $group in $groups return imf:get-all-attributes($group)"/>
    </xsl:function>
    
    <!-- =================== cleanup =================== -->
   
    <!--XX
    <xsl:template match="xs:schema" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:variable name="names" select="for $n in (xs:*/@name) return string($n)" as="xs:string*"/>
            <xsl:variable name="names-dup" select="distinct-values($names[count(index-of($names,.)) gt 1])"/>
            <xsl:apply-templates mode="xsd-cleanup">
                <xsl:with-param name="names-dup" select="$names-dup"/>
            </xsl:apply-templates>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="xs:complexType | xs:simpleType" mode="xsd-cleanup">
        <xsl:param name="names-dup"/>
        <xsl:variable name="name" select="@name"/>
        <xsl:choose>
            <xsl:when test="($name = $names-dup) and (preceding-sibling::xs:*/@name = $name)">
                <xsl:sequence select="imf:create-comment(concat('xsd-cleanup Duplicate removed', ()))"/>
            </xsl:when>
            <xsl:otherwise>
                <xsl:next-match/>
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>
    XX-->
    
    <xsl:template match="*" mode="xsd-cleanup">
        <xsl:copy>
            <xsl:copy-of select="@*"/>
            <xsl:apply-templates mode="xsd-cleanup"/>
        </xsl:copy>
    </xsl:template>
    
    <xsl:template match="comment()" mode="xsd-cleanup">
        <xsl:if test="$allow-comments-in-schema">
            <xsl:sequence select="."/>
        </xsl:if>
    </xsl:template>
    
    <xsl:template match="imvert:dummy"/>
</xsl:stylesheet>
